<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Totum Chat - Improved</title>
    <!-- Improved version with session syncing and timestamps -->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="highlight-theme">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        html, body { height: 100%; }
        .sidebar { 
            width: 280px; 
            background-color: var(--bs-dark-bg-subtle) !important;
            border-right: 1px solid var(--bs-border-color);
        }
        .chat-container { 
            flex: 1;
            overflow-y: auto; 
            max-height: calc(100vh - 140px);
        }
        .message-avatar { 
            width: 32px; 
            height: 32px; 
            font-size: 14px;
            flex-shrink: 0;
        }
        .streaming-indicator { 
            animation: blink 1s step-start infinite; 
        }
        @keyframes blink { 50% { opacity: 0; } }
        
        .code-actions { 
            position: absolute; 
            top: 8px; 
            right: 8px; 
            display: none;
        }
        pre:hover .code-actions { display: block; }
        pre { position: relative; }
        
        .model-gemini.active { 
            background-color: #4285f4 !important; 
            border-color: #4285f4 !important; 
            color: white !important;
        }
        .model-llama.active { 
            background-color: #10a37f !important; 
            border-color: #10a37f !important; 
            color: white !important;
        }
        .model-openai.active { 
            background-color: #41A58F !important; 
            border-color: #41A58F !important; 
            color: white !important;
        }
        
        .avatar-gemini { background-color: #4285f4; }
        .avatar-llama { background-color: #10a37f; }
        .avatar-openai { background-color: #41A58F; }
        
        .staged-file { 
            background-color: var(--bs-secondary-bg);
            border: 1px solid var(--bs-border-color);
        }
        
        .session-item {
            cursor: pointer;
            padding: 8px 12px;
            margin-bottom: 2px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            border: none;
            color: var(--bs-body-color);
        }
        .session-item:hover {
            background-color: var(--bs-secondary-bg);
        }
        .session-item.active {
            background-color: var(--bs-primary);
            color: white;
        }
        .session-item .delete-btn {
            opacity: 0;
            transition: opacity 0.2s;
        }
        .session-item:hover .delete-btn {
            opacity: 1;
        }

        .chat-input-area {
            border-top: 1px solid var(--bs-border-color);
            background-color: var(--bs-body-bg);
        }
    </style>
</head>
<body>
    <div class="d-flex h-100">
        <div class="sidebar d-none d-md-flex flex-column h-100">
            <div class="p-3 flex-grow-1">
                <button class="btn btn-primary w-100 mb-3" id="newChatBtn">
                    <i class="bi bi-plus"></i> New chat
                </button>
                
                <div class="mb-3" style="height: 300px; overflow-y: auto;" id="sessionsList">
                    <!-- Sessions will be populated here -->
                </div>

                <button class="btn btn-outline-secondary w-100 mb-3" id="saveSessionBtn">
                    <i class="bi bi-save"></i> Save chat
                </button>

                <!-- Model Selection -->
                <div class="btn-group w-100 mb-2" role="group">
                    <button class="btn btn-outline-secondary model-gemini" id="geminiBtn">Gemini</button>
                    <button class="btn btn-outline-secondary model-llama" id="llamaBtn">Llama</button>
                    <button class="btn btn-outline-secondary model-openai" id="openaiBtn">OpenAI</button>
                </div>

                <!-- Gemini Config -->
                <div id="geminiConfig" class="d-none">
                    <input type="password" class="form-control form-control-sm mb-2" id="geminiApiKey" placeholder="Google AI Studio API Key">
                    <select class="form-select form-select-sm mb-2" id="geminiModelSelect" disabled>
                        <option>-- Enter API Key First --</option>
                    </select>
                    <div class="text-center">
                        <small class="text-muted" id="tokenCounter">
                            <span id="tokenCountValue">0</span> tokens
                        </small>
                    </div>
                </div>

                <!-- Llama Config -->
                <div id="llamaConfig" class="d-none">
                    <input type="url" class="form-control form-control-sm mb-2" id="llamaServerUrl" placeholder="Server URL" value="http://127.0.0.1:8080">
                </div>

                <!-- OpenAI Config -->
                <div id="openaiConfig" class="d-none">
                    <input type="password" class="form-control form-control-sm mb-2" id="openaiApiKey" placeholder="OpenAI API Key">
                    <select class="form-select form-select-sm mb-2" id="openaiModelSelect" disabled>
                        <option>-- Enter API Key First --</option>
                    </select>
                </div>
            </div>

            <!-- Bottom Actions -->
            <div class="p-3 border-top">
                <div class="d-flex gap-2">
                    <button class="btn btn-outline-secondary btn-sm flex-fill" data-bs-toggle="modal" data-bs-target="#settingsModal">
                        <i class="bi bi-gear"></i>
                    </button>
                    <button class="btn btn-outline-secondary btn-sm" id="themeSwitcher">ðŸŒ™</button>
                    <button class="btn btn-outline-secondary btn-sm" data-bs-toggle="modal" data-bs-target="#importExportModal">
                        <i class="bi bi-folder"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-grow-1 d-flex flex-column h-100">
            <!-- Mobile Menu Button -->
            <button class="btn btn-outline-secondary d-md-none position-fixed top-0 start-0 m-3" style="z-index: 1050;" data-bs-toggle="offcanvas" data-bs-target="#mobileSidebar">
                <i class="bi bi-list"></i>
            </button>

            <!-- Chat Container -->
            <div class="chat-container p-4" id="chatContainer">
                <div class="text-center py-5">
                    <h2>Totum Chat</h2>
                    <p class="text-muted">Chat with Gemini, Llama, or OpenAI models</p>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="chat-input-area p-3">
                <div class="container-fluid">
                    <div class="row justify-content-center">
                        <div class="col-lg-8 col-xl-6">
                            <div class="card">
                                <div class="card-body p-3">
                                    <div id="stagedFilesArea" class="d-none mb-2">
                                        <!-- Staged files -->
                                    </div>
                                    <div class="input-group">
                                        <textarea class="form-control" id="chatInput" placeholder="Message..." rows="1" style="resize: none;"></textarea>
                                        <label class="btn btn-outline-secondary" for="fileInput">
                                            <i class="bi bi-paperclip"></i>
                                        </label>
                                        <button class="btn btn-primary" id="sendButton" disabled>
                                            <i class="bi bi-send"></i>
                                        </button>
                                    </div>
                                    <input type="file" id="fileInput" class="d-none" multiple>
                                </div>
                            </div>
                            <div class="text-center mt-2">
                                <small class="text-muted" id="statusBar"></small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Sidebar -->
    <div class="offcanvas offcanvas-start" id="mobileSidebar">
        <div class="offcanvas-header">
            <h5>Totum Chat</h5>
            <button class="btn-close" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body">
            <button class="btn btn-primary w-100 mb-3" onclick="document.getElementById('newChatBtn').click(); bootstrap.Offcanvas.getInstance(document.getElementById('mobileSidebar')).hide();">
                <i class="bi bi-plus"></i> New chat
            </button>
            <div class="mb-3" style="height: 200px; overflow-y: auto;" id="sessionsListMobile">
                <!-- Sessions mirror -->
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Settings</h5>
                    <button class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">Temperature</label>
                        <input type="number" class="form-control" id="temperature" min="0" max="2" step="0.1" value="0.7">
                        <small class="text-muted">Controls randomness</small>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Max Tokens</label>
                        <input type="number" class="form-control" id="maxTokens" min="1" value="2048">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Top P</label>
                        <input type="number" class="form-control" id="topP" min="0" max="1" step="0.01" value="0.95">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Top K</label>
                        <input type="number" class="form-control" id="topK" min="1" value="40">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Stop Sequences</label>
                        <input type="text" class="form-control" id="stopSequences" value="USER:, \nUSER:, <|user|>">
                    </div>
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="rememberConfig">
                        <label class="form-check-label">Remember API Keys</label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import/Export Modal -->
    <div class="modal fade" id="importExportModal">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Import/Export</h5>
                    <button class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <button class="btn btn-primary w-100 mb-2" id="exportAllBtn">Export All Chats</button>
                    <button class="btn btn-primary w-100" id="importChatsBtn">Import Chats</button>
                    <input type="file" id="importFileInput" class="d-none" accept=".json">
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        'use strict';

        // Constants & State
        const SESSION_INDEX_KEY = 'unifiedChatIndex';
        const SESSION_DATA_PREFIX = 'unifiedChatSession_';
        const MAX_TEXT_FILE_EMBED_SIZE = 200 * 1024;
        const GEMINI_API_BASE = "https://generativelanguage.googleapis.com/v1beta/";
        const OPENAI_API_BASE = "https://api.openai.com/v1/";

        let chatHistory = [];
        let currentSessionId = null;
        let currentAbortController = null;
        let messageCounter = 0;
        let stagedFiles = [];
        let currentModelType = 'gemini';
        let geminiModelsLoaded = false;
        let openaiModelsLoaded = false;

        // DOM Elements
        const $ = id => document.getElementById(id);
        const elements = {
            sidebar: document.querySelector('.sidebar'),
            newChatBtn: $('newChatBtn'),
            sessionsList: $('sessionsList'),
            saveSessionBtn: $('saveSessionBtn'),
            geminiBtn: $('geminiBtn'),
            llamaBtn: $('llamaBtn'),
            openaiBtn: $('openaiBtn'),
            geminiConfig: $('geminiConfig'),
            llamaConfig: $('llamaConfig'),
            openaiConfig: $('openaiConfig'),
            geminiApiKey: $('geminiApiKey'),
            geminiModelSelect: $('geminiModelSelect'),
            llamaServerUrl: $('llamaServerUrl'),
            openaiApiKey: $('openaiApiKey'),
            openaiModelSelect: $('openaiModelSelect'),
            themeSwitcher: $('themeSwitcher'),
            temperature: $('temperature'),
            maxTokens: $('maxTokens'),
            topP: $('topP'),
            topK: $('topK'),
            stopSequences: $('stopSequences'),
            rememberConfig: $('rememberConfig'),
            exportAllBtn: $('exportAllBtn'),
            importChatsBtn: $('importChatsBtn'),
            importFileInput: $('importFileInput'),
            chatContainer: $('chatContainer'),
            chatInput: $('chatInput'),
            sendButton: $('sendButton'),
            fileInput: $('fileInput'),
            stagedFilesArea: $('stagedFilesArea'),
            statusBar: $('statusBar'),
            tokenCounter: $('tokenCounter'),
            tokenCountValue: $('tokenCountValue')
        };

        // Initialize
        function initialize() {
            loadConfig();
            setupEventListeners();
            initializeTheme();
            configureMarked();
            populateSessions();
            switchModel(currentModelType);
            updateSendButtonState();
        }

        function setupEventListeners() {
            // Model Selection
            elements.geminiBtn.addEventListener('click', () => switchModel('gemini'));
            elements.llamaBtn.addEventListener('click', () => switchModel('llama'));
            elements.openaiBtn.addEventListener('click', () => switchModel('openai'));
            
            // API Keys - with debouncing
            elements.geminiApiKey.addEventListener('input', debounce(handleGeminiApiKeyInput, 500));
            elements.openaiApiKey.addEventListener('input', debounce(handleOpenAIApiKeyInput, 500));
            elements.llamaServerUrl.addEventListener('input', debounce(() => { saveConfig(); updateSendButtonState(); }, 500));
            
            // Chat
            elements.newChatBtn.addEventListener('click', startNewSession);
            elements.saveSessionBtn.addEventListener('click', handleSaveSession);
            elements.sendButton.addEventListener('click', handleSendPrompt);
            
            elements.chatInput.addEventListener('input', () => {
                updateSendButtonState();
                autoResizeTextarea(elements.chatInput);
            });
            
            elements.chatInput.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    if (!elements.sendButton.disabled && !currentAbortController) {
                        handleSendPrompt();
                    }
                }
            });
            
            // Files
            elements.fileInput.addEventListener('change', handleFileSelection);
            elements.stagedFilesArea.addEventListener('click', handleRemoveStagedFile);
            
            // Theme
            elements.themeSwitcher.addEventListener('click', toggleTheme);
            
            // Import/Export
            elements.exportAllBtn.addEventListener('click', handleExportAll);
            elements.importChatsBtn.addEventListener('click', () => elements.importFileInput.click());
            elements.importFileInput.addEventListener('change', handleImportChats);
            
            // Settings
            elements.rememberConfig.addEventListener('change', handleRememberConfigChange);
            
            // Chat interactions
            elements.chatContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('copy-code-button')) {
                    handleCopyCodeClick(e.target);
                } else if (e.target.classList.contains('download-code-button')) {
                    handleDownloadCodeClick(e.target);
                }
            });
            
            // Sessions
            elements.sessionsList.addEventListener('click', (e) => {
                const sessionItem = e.target.closest('.session-item');
                const deleteBtn = e.target.closest('.delete-btn');
                
                if (deleteBtn && sessionItem) {
                    e.stopPropagation();
                    handleDeleteSession(sessionItem.dataset.sessionId);
                } else if (sessionItem) {
                    handleLoadSession(sessionItem.dataset.sessionId);
                    const offcanvas = bootstrap.Offcanvas.getInstance($('mobileSidebar'));
                    if (offcanvas) offcanvas.hide();
                }
            });
        }

        function configureMarked() {
            marked.setOptions({
                highlight: (code, lang) => {
                    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                    try {
                        return hljs.highlight(code, { language, ignoreIllegals: true }).value;
                    } catch (e) {
                        console.warn("Highlight.js error:", e);
                        return escapeHtml(code);
                    }
                },
                gfm: true,
                breaks: true,
                langPrefix: 'hljs language-'
            });
        }

        // Model Management
        function switchModel(modelType) {
            currentModelType = modelType;
            
            // Reset button states
            [elements.geminiBtn, elements.llamaBtn, elements.openaiBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            [elements.geminiConfig, elements.llamaConfig, elements.openaiConfig].forEach(config => {
                config.classList.add('d-none');
            });

            if (modelType === 'gemini') {
                elements.geminiBtn.classList.add('active');
                elements.geminiConfig.classList.remove('d-none');
                if (elements.geminiApiKey.value.trim() && !geminiModelsLoaded) {
                    fetchGeminiModels();
                }
            } else if (modelType === 'llama') {
                elements.llamaBtn.classList.add('active');
                elements.llamaConfig.classList.remove('d-none');
            } else if (modelType === 'openai') {
                elements.openaiBtn.classList.add('active');
                elements.openaiConfig.classList.remove('d-none');
                if (elements.openaiApiKey.value.trim() && !openaiModelsLoaded) {
                    fetchOpenAIModels();
                }
            }
            
            updateSendButtonState();
            saveConfig();
        }

        // API Functions
        async function fetchGeminiModels() {
            const apiKey = elements.geminiApiKey.value.trim();
            if (!apiKey) return;
            
            geminiModelsLoaded = false;
            updateModelDropdown(elements.geminiModelSelect, [], "Loading...");
            
            try {
                const response = await fetch(`${GEMINI_API_BASE}models?key=${apiKey}`);
                if (!response.ok) throw new Error(`Failed to list models: ${response.status}`);
                
                const data = await response.json();
                const models = (data.models || [])
                    .filter(m => m.name.startsWith('models/') && m.supportedGenerationMethods?.includes('generateContent'))
                    .sort((a, b) => (a.displayName || a.name).localeCompare(b.displayName || b.name));
                
                updateModelDropdown(elements.geminiModelSelect, models.map(m => ({
                    value: m.name,
                    text: (m.displayName || m.name.split('/').pop()) + (m.name.includes('gemini-1.5-pro') ? ' (Multimodal)' : '')
                })));
                geminiModelsLoaded = true;
            } catch (error) {
                console.error("Fetch Gemini Models Error:", error);
                showStatus(`Error: ${error.message}`, true);
                updateModelDropdown(elements.geminiModelSelect, [], "Error loading models");
            }
        }

        async function fetchOpenAIModels() {
            const apiKey = elements.openaiApiKey.value.trim();
            if (!apiKey) return;

            openaiModelsLoaded = false;
            updateModelDropdown(elements.openaiModelSelect, [], "Loading...");

            try {
                const response = await fetch(`${OPENAI_API_BASE}models`, {
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });
                if (!response.ok) throw new Error(`Failed to list models: ${response.status}`);

                const data = await response.json();
                const models = (data.data || [])
                    .filter(m => m.id.includes('gpt-'))
                    .sort((a, b) => {
                        const order = ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'];
                        const aOrder = order.findIndex(p => a.id.startsWith(p));
                        const bOrder = order.findIndex(p => b.id.startsWith(p));
                        if (aOrder !== -1 && bOrder !== -1) return aOrder - bOrder;
                        if (aOrder !== -1) return -1;
                        if (bOrder !== -1) return 1;
                        return b.id.localeCompare(a.id);
                    });

                updateModelDropdown(elements.openaiModelSelect, models.map(m => ({ 
                    value: m.id, 
                    text: m.id 
                })));
                openaiModelsLoaded = true;
            } catch (error) {
                console.error("Fetch OpenAI Models Error:", error);
                showStatus(`OpenAI Error: ${error.message}`, true);
                updateModelDropdown(elements.openaiModelSelect, [], "Error loading models");
            }
        }

        function updateModelDropdown(select, models, placeholder = "-- Select a Model --") {
            const previousValue = select.value;
            select.innerHTML = `<option value="" disabled selected>${placeholder}</option>`;
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.text;
                if (model.value === previousValue || (!previousValue && (
                    model.value.includes('gemini-1.5-pro-latest') || model.value.startsWith('gpt-4o')
                ))) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            select.disabled = models.length === 0;
            updateSendButtonState();
        }

        // Send Message
        async function handleSendPrompt() {
            if (currentAbortController) {
                currentAbortController.abort();
                showStatus("Generation stopped", false);
                resetSendButton();
                return;
            }

            const promptText = elements.chatInput.value.trim();
            if (!promptText && !stagedFiles.length) {
                showStatus("Message cannot be empty", true);
                return;
            }

            currentAbortController = new AbortController();
            elements.sendButton.innerHTML = '<i class="bi bi-stop-fill"></i>';
            elements.chatInput.disabled = true;

            let userContentForHistory = promptText;
            let fileInfoForHistory = null;
            
            if (stagedFiles.length > 0) {
                fileInfoForHistory = stagedFiles.map(f => ({
                    name: f.name,
                    type: f.type,
                    data: f.content 
                }));
            }

            const userMessage = {
                id: `msg-${messageCounter++}`,
                role: 'user',
                content: userContentForHistory,
                fileInfo: fileInfoForHistory,
                timestamp: new Date(),
                model: currentModelType,
                displayContent: promptText
            };

            const assistantMessage = {
                id: `msg-${messageCounter++}`,
                role: 'assistant',
                content: '',
                timestamp: new Date(),
                model: currentModelType
            };

            chatHistory.push(userMessage, assistantMessage);
            renderChatHistory();
            scrollToBottom();

            elements.chatInput.value = '';
            autoResizeTextarea(elements.chatInput);
            clearStagedFiles();

            try {
                if (currentModelType === 'gemini') {
                    await sendToGemini(assistantMessage);
                } else if (currentModelType === 'llama') {
                    await sendToLlama(assistantMessage, prepareUserContentForLlama(promptText));
                } else if (currentModelType === 'openai') {
                    await sendToOpenAI(assistantMessage);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Send error:", error);
                    showStatus(`Error: ${error.message}`, true);
                    const index = chatHistory.findIndex(m => m.id === assistantMessage.id);
                    if (index > -1 && assistantMessage.content === '') {
                        chatHistory.splice(index, 1);
                        renderChatHistory();
                    }
                }
            } finally {
                resetSendButton();
                if (currentModelType === 'gemini') updateTokenCount();
            }
        }

        function prepareUserContentForLlama(promptText) {
            if (!stagedFiles.length) return promptText;
            
            let content = "Attached Files:\n";
            stagedFiles.forEach(file => {
                content += `[File: ${file.name} (${file.type})]\n`;
                if (file.type.startsWith('text/') && typeof file.content === 'string') {
                    let textContent = file.content;
                    if (file.content.startsWith('data:')) {
                        try {
                            const base64Decoded = atob(file.content.split(',')[1]);
                            textContent = decodeURIComponent(escape(base64Decoded));
                        } catch (e) {
                            console.error("Error decoding DataURL for Llama text file:", e);
                            content += `Content: [Error decoding file for embedding]\n`;
                            return;
                        }
                    }
                    if (textContent.length < MAX_TEXT_FILE_EMBED_SIZE) {
                        content += `Content:\n---\n${textContent}\n---\n`;
                    } else {
                        content += `Content: [File too large: ${textContent.length} bytes]\n`;
                    }
                }
            });
            return content + "\nUser Message:\n" + promptText;
        }

        // API Send Functions
        async function sendToGemini(assistantMessage) {
            const apiKey = elements.geminiApiKey.value.trim();
            const model = elements.geminiModelSelect.value;
            
            showStatus("Generating response (Gemini)...", false);
            
            const contentsForApi = chatHistory.slice(0, -1).map(msg => {
                const role = msg.role === 'user' ? 'user' : 'model';
                const parts = [{ text: msg.displayContent || msg.content }];
                
                if (msg.role === 'user' && msg.fileInfo && Array.isArray(msg.fileInfo)) {
                    msg.fileInfo.forEach(file => {
                        if (file.data && file.data.startsWith('data:')) {
                            const [header, base64Data] = file.data.split(',');
                            const mimeType = header.match(/:(.*?);/)?.[1] || file.type;
                            if (base64Data && mimeType) {
                                parts.push({
                                    inlineData: {
                                        mimeType: mimeType,
                                        data: base64Data
                                    }
                                });
                            }
                        }
                    });
                }
                return { role, parts };
            });
            
            const apiUrl = `${GEMINI_API_BASE}${model}:streamGenerateContent?key=${apiKey}&alt=sse`;
            const requestBody = {
                contents: contentsForApi,
                generationConfig: {
                    temperature: parseFloat(elements.temperature.value),
                    maxOutputTokens: parseInt(elements.maxTokens.value, 10),
                    topP: parseFloat(elements.topP.value),
                    topK: parseInt(elements.topK.value, 10)
                }
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }
            
            await processStreamResponse(response, assistantMessage, 'gemini');
        }

        async function sendToLlama(assistantMessage, userContentForLlama) {
            const serverUrl = elements.llamaServerUrl.value.trim();
            showStatus("Connecting to Llama server...", false);
            
            const historyForLlama = chatHistory.slice(0, -2);
            let prompt = "";
            historyForLlama.forEach(message => {
                if (message.role === 'user') {
                    prompt += `USER: ${message.displayContent || message.content}\n`;
                } else if (message.role === 'assistant') {
                    prompt += `ASSISTANT: ${message.content}\n`;
                }
            });
            prompt += `USER: ${userContentForLlama}\nASSISTANT:`;
            
            const apiUrl = `${serverUrl}/completion`;
            const requestBody = {
                prompt: prompt,
                temperature: parseFloat(elements.temperature.value),
                n_predict: parseInt(elements.maxTokens.value, 10),
                top_p: parseFloat(elements.topP.value),
                top_k: parseInt(elements.topK.value, 10),
                stop: elements.stopSequences.value.split(',').map(s => s.trim()).filter(s => s),
                stream: true
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });
            
            if (!response.ok || !response.body) {
                throw new Error(`Llama Server Error: ${response.status} ${response.statusText}`);
            }
            
            await processStreamResponse(response, assistantMessage, 'llama');
        }

        async function sendToOpenAI(assistantMessage) {
            const apiKey = elements.openaiApiKey.value.trim();
            const model = elements.openaiModelSelect.value;

            showStatus("Generating response (OpenAI)...", false);

            const messagesForApi = chatHistory.slice(0, -1).map(msg => {
                let contentForApi;
                if (msg.role === 'user') {
                    const contentParts = [{ type: "text", text: msg.displayContent || msg.content }];
                    if (msg.fileInfo && Array.isArray(msg.fileInfo)) {
                        msg.fileInfo.forEach(file => {
                            if (file.data && file.data.startsWith('data:image/')) {
                                contentParts.push({
                                    type: "image_url",
                                    image_url: { url: file.data }
                                });
                            }
                        });
                    }
                    contentForApi = contentParts;
                } else {
                    contentForApi = msg.content;
                }
                return { role: msg.role === 'user' ? 'user' : 'assistant', content: contentForApi };
            });

            const apiUrl = `${OPENAI_API_BASE}chat/completions`;
            const requestBody = {
                model: model,
                messages: messagesForApi,
                temperature: parseFloat(elements.temperature.value),
                max_tokens: parseInt(elements.maxTokens.value, 10),
                top_p: parseFloat(elements.topP.value),
                stop: elements.stopSequences.value.split(',').map(s => s.trim()).filter(s => s),
                stream: true
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`OpenAI API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }

            await processStreamResponse(response, assistantMessage, 'openai');
        }

        // Unified stream processing
        async function processStreamResponse(response, assistantMessage, provider) {
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                buffer += value;
                const lines = buffer.split(provider === 'llama' ? '\n\n' : '\n');
                buffer = lines.pop();
                
                for (const line of lines) {
                    if (provider === 'llama' && line.startsWith('data: ')) {
                        const jsonData = line.substring(6).trim();
                        if (jsonData) {
                            try {
                                const data = JSON.parse(jsonData);
                                if (typeof data.content === 'string') {
                                    assistantMessage.content += data.content;
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, true);
                                }
                                if (data.stop) {
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, false);
                                    showStatus("Response complete (Llama)", false);
                                    return;
                                }
                            } catch (e) {
                                console.error("Error parsing Llama stream JSON:", e, jsonData);
                            }
                        }
                    } else if (provider !== 'llama' && line.startsWith('data:')) {
                        const jsonStr = line.substring(5).trim();
                        if (jsonStr === '[DONE]') {
                            updateMessageBubble(assistantMessage.id, assistantMessage.content, false);
                            showStatus("Response complete", false);
                            return;
                        }
                        if (jsonStr) {
                            try {
                                const chunkData = JSON.parse(jsonStr);
                                let textPart = '';
                                if (provider === 'gemini') {
                                    textPart = chunkData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                                } else if (provider === 'openai') {
                                    textPart = chunkData.choices?.[0]?.delta?.content || '';
                                }
                                if (textPart) {
                                    assistantMessage.content += textPart;
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, true);
                                }
                            } catch (e) {
                                console.error(`Error parsing ${provider} stream chunk:`, e, jsonStr);
                            }
                        }
                    }
                }
            }
            
            updateMessageBubble(assistantMessage.id, assistantMessage.content, false);
            showStatus("Response complete", false);
        }

        function resetSendButton() {
            currentAbortController = null;
            elements.sendButton.innerHTML = '<i class="bi bi-send"></i>';
            elements.chatInput.disabled = false;
            updateSendButtonState();
            elements.chatInput.focus();
        }

        // File Handling
        function handleFileSelection(event) {
            const files = event.target.files;
            if (!files) return;
            
            const newFiles = Array.from(files).filter(file =>
                !stagedFiles.some(staged => staged.name === file.name)
            );
            
            if (newFiles.length === 0) return;
            showStatus("Processing files...", false);
            
            let filesProcessed = 0;
            newFiles.forEach(file => {
                const reader = new FileReader();
                const fileData = {
                    name: file.name,
                    type: file.type || 'application/octet-stream',
                    content: null,
                    error: null
                };
                stagedFiles.push(fileData);
                
                reader.onload = function(e) {
                    fileData.content = e.target.result;
                    filesProcessed++;
                    if (filesProcessed === newFiles.length) {
                        renderStagedFiles();
                        showStatus("Files ready", false);
                        updateSendButtonState();
                    }
                };
                
                reader.onerror = function(e) {
                    fileData.error = "Error reading file";
                    filesProcessed++;
                    if (filesProcessed === newFiles.length) {
                        renderStagedFiles();
                        showStatus("Some files had errors", true);
                    }
                };
                
                if (currentModelType === 'llama' && file.type.startsWith('text/')) {
                    reader.readAsText(file);
                } else {
                    reader.readAsDataURL(file);
                }
            });
            
            renderStagedFiles();
            event.target.value = null;
        }

        function renderStagedFiles() {
            if (!stagedFiles.length) {
                elements.stagedFilesArea.classList.add('d-none');
                elements.stagedFilesArea.innerHTML = '';
                return;
            }
            
            elements.stagedFilesArea.classList.remove('d-none');
            elements.stagedFilesArea.innerHTML = stagedFiles.map((file, index) => `
                <span class="badge staged-file me-1 mb-1 d-inline-flex align-items-center">
                    ${escapeHtml(file.name)}
                    <button class="btn-close btn-close-white btn-sm ms-1" data-index="${index}" style="font-size: 0.7em;"></button>
                </span>
            `).join('');
        }

        function handleRemoveStagedFile(event) {
            if (event.target.classList.contains('btn-close')) {
                const index = parseInt(event.target.dataset.index, 10);
                stagedFiles.splice(index, 1);
                renderStagedFiles();
                updateSendButtonState();
            }
        }

        function clearStagedFiles() {
            stagedFiles = [];
            renderStagedFiles();
            elements.fileInput.value = null;
        }

        // Chat Rendering
        function renderChatHistory() {
            if (chatHistory.length === 0) {
                elements.chatContainer.innerHTML = `
                    <div class="text-center py-5">
                        <h2>Totum Chat</h2>
                        <p class="text-muted">Chat with Gemini, Llama, or OpenAI models</p>
                    </div>
                `;
                return;
            }
            
            elements.chatContainer.innerHTML = '';
            chatHistory.forEach(message => {
                const messageElement = createMessageElement(message);
                elements.chatContainer.appendChild(messageElement);
            });
            
            updateSessionButtonState();
const sessionsListMobile = document.getElementById('sessionsListMobile');
    if (sessionsListMobile) {
        sessionsListMobile.innerHTML = '';
        elements.sessionsList.querySelectorAll('.session-item').forEach(item => {
            const clone = item.cloneNode(true);
            sessionsListMobile.appendChild(clone);
        });
    }
        }

        function createMessageElement(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'd-flex mb-4';
            messageDiv.dataset.messageId = message.id;
            
            const isUser = message.role === 'user';
            const avatarClass = isUser ? 'bg-primary' : `avatar-${message.model}`;
            const avatarText = isUser ? 'U' : { gemini: 'G', llama: 'L', openai: 'O' }[message.model] || 'A';
            
            let content = '';
            if (isUser) {
                content = escapeHtml(message.displayContent || message.content);
                if (message.fileInfo && message.fileInfo.length > 0) {
                    content += `<div class="mt-2 small opacity-75">ðŸ“Ž ${message.fileInfo.map(f => escapeHtml(f.name)).join(', ')}</div>`;
                }
            } else {
                if (message.content) {
                    try {
                        content = marked.parse(message.content);
                    } catch (e) {
                        content = escapeHtml(message.content);
                    }
                } else {
                    content = '<span class="streaming-indicator">â–Œ</span>';
                }
            }
            
            messageDiv.innerHTML = `
                <div class="message-avatar rounded ${avatarClass} text-white d-flex align-items-center justify-content-center me-3">
                    ${avatarText}
                </div>
                <div class="flex-grow-1">
                    <div class="message-body">${content}
<small class="text-muted d-block mt-1">${new Date(message.timestamp).toLocaleString()}</small>
</div>
                </div>
            `;
            
            return messageDiv;
        }

        function updateMessageBubble(messageId, content, isStreaming) {
            const messageDiv = elements.chatContainer.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageDiv) return;
            
            const bodyDiv = messageDiv.querySelector('.message-body');
            if (!bodyDiv) return;
            
            if (isStreaming && content) {
                bodyDiv.textContent = content;
                if (!bodyDiv.querySelector('.streaming-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'streaming-indicator';
                    indicator.textContent = 'â–Œ';
                    bodyDiv.appendChild(indicator);
                }
            } else {
                try {
                    bodyDiv.innerHTML = marked.parse(content || '[Empty Response]');
                    addCodeActionsToBubble(bodyDiv);
                } catch (e) {
                    bodyDiv.textContent = content || '[Error rendering response]';
                }
            }
            
            scrollToBottom();
        }

        function addCodeActionsToBubble(container) {
            const preBlocks = container.querySelectorAll('pre');
            preBlocks.forEach(pre => {
                if (pre.querySelector('.code-actions')) return;
                
                const codeElement = pre.querySelector('code');
                if (!codeElement) return;
                
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'code-actions';
                
                const copyButton = document.createElement('button');
                copyButton.textContent = 'Copy';
                copyButton.className = 'btn btn-sm btn-outline-secondary copy-code-button me-1';
                
                const downloadButton = document.createElement('button');
                downloadButton.textContent = 'Download';
                downloadButton.className = 'btn btn-sm btn-outline-secondary download-code-button';
                
                actionsContainer.appendChild(copyButton);
                actionsContainer.appendChild(downloadButton);
                pre.insertBefore(actionsContainer, pre.firstChild);
                
                if (!codeElement.classList.contains('hljs')) {
                    try {
                        hljs.highlightElement(codeElement);
                    } catch(e) {
                        console.warn("Highlighting failed for code block:", e);
                    }
                }
            });
        }

        function handleCopyCodeClick(button) {
            const pre = button.closest('pre');
            const code = pre?.querySelector('code');
            if (!code) return;
            
            navigator.clipboard.writeText(code.textContent || '').then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('btn-success');
                button.classList.remove('btn-outline-secondary');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-success');
                    button.classList.add('btn-outline-secondary');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                showStatus('Failed to copy code.', true);
            });
        }

        function handleDownloadCodeClick(button) {
            const pre = button.closest('pre');
            const code = pre?.querySelector('code');
            if (!code) return;
            
            const codeContent = code.textContent || '';
            let language = 'txt';
            const langClass = Array.from(code.classList).find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '').split(' ')[0];
            }
            
            const extensionMap = {
                javascript: '.js', js: '.js', python: '.py', py: '.py', html: '.html', css: '.css',
                json: '.json', xml: '.xml', yaml: '.yaml', yml: '.yaml', markdown: '.md', md: '.md',
                java: '.java', cpp: '.cpp', c: '.c', csharp: '.cs', cs: '.cs', go: '.go',
                rust: '.rs', ruby: '.rb', php: '.php', sql: '.sql', bash: '.sh', shell: '.sh',
                plaintext: '.txt', text: '.txt'
            };
            
            const extension = extensionMap[language.toLowerCase()] || `.${language}` || '.txt';
            const filename = `code-snippet${extension}`;
            
            const blob = new Blob([codeContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Session Management
        function getSessionIndex() {
            try {
                const indexJson = localStorage.getItem(SESSION_INDEX_KEY);
                if (!indexJson) return [];
                const index = JSON.parse(indexJson);
                return Array.isArray(index) ? index : [];
            } catch (e) {
                console.error("Error reading session index:", e);
                return [];
            }
        }

        function saveSessionIndex(index) {
            try {
                localStorage.setItem(SESSION_INDEX_KEY, JSON.stringify(index));
            } catch (e) {
                console.error("Error saving session index:", e);
                showStatus("Error saving session index", true);
            }
        }

        function populateSessions() {
            const sessions = getSessionIndex();
            elements.sessionsList.innerHTML = '';
            
            sessions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

            sessions.forEach(session => {
                const sessionItem = document.createElement('div');
                sessionItem.className = 'session-item';
                sessionItem.dataset.sessionId = session.id;
                sessionItem.innerHTML = `
                    <span class="text-truncate me-2">${escapeHtml(session.name)}</span>
                    <button class="btn btn-sm btn-outline-danger delete-btn">&times;</button>
                `;
                
                if (session.id === currentSessionId) {
                    sessionItem.classList.add('active');
                }
                
                elements.sessionsList.appendChild(sessionItem);
            });
            
            updateSessionButtonState();
const sessionsListMobile = document.getElementById('sessionsListMobile');
    if (sessionsListMobile) {
        sessionsListMobile.innerHTML = '';
        elements.sessionsList.querySelectorAll('.session-item').forEach(item => {
            const clone = item.cloneNode(true);
            sessionsListMobile.appendChild(clone);
        });
    }
        }

        function startNewSession() {
            if (currentAbortController) {
                currentAbortController.abort();
            }
            
            chatHistory = [];
            currentSessionId = null;
            messageCounter = 0;
            clearStagedFiles();
            renderChatHistory();
            elements.chatInput.value = '';
            autoResizeTextarea(elements.chatInput);
            showStatus("", false);
            updateSessionButtonState();
const sessionsListMobile = document.getElementById('sessionsListMobile');
    if (sessionsListMobile) {
        sessionsListMobile.innerHTML = '';
        elements.sessionsList.querySelectorAll('.session-item').forEach(item => {
            const clone = item.cloneNode(true);
            sessionsListMobile.appendChild(clone);
        });
    }
            resetSendButton();
            
            document.querySelectorAll('.session-item.active').forEach(item => {
                item.classList.remove('active');
            });
        }

        function handleSaveSession() {
            if (chatHistory.length === 0) {
                showStatus("Nothing to save", true);
                return;
            }
            
            const sessions = getSessionIndex();
            let defaultName = `Chat ${new Date().toLocaleString()}`;
            
            if (currentSessionId) {
                const existing = sessions.find(s => s.id === currentSessionId);
                if (existing) defaultName = existing.name;
            }
            
            const sessionName = prompt("Enter a name for this session:", defaultName);
            if (!sessionName) return;
            
            const trimmedName = sessionName.trim();
            if (!trimmedName) {
                showStatus("Session name cannot be empty", true);
                return;
            }
            
            try {
                let sessionIdToSave = currentSessionId;
                const now = Date.now();
                
                if (!sessionIdToSave) {
                    sessionIdToSave = `${SESSION_DATA_PREFIX}${now}-${Math.random().toString(36).slice(2, 9)}`;
                    sessions.push({ id: sessionIdToSave, name: trimmedName, timestamp: now });
                    currentSessionId = sessionIdToSave;
                } else {
                    const existingIndex = sessions.findIndex(s => s.id === sessionIdToSave);
                    if (existingIndex > -1) {
                        sessions[existingIndex].name = trimmedName;
                        sessions[existingIndex].timestamp = now;
                    } else {
                        sessions.push({ id: sessionIdToSave, name: trimmedName, timestamp: now });
                    }
                }
                
                localStorage.setItem(`${SESSION_DATA_PREFIX}${sessionIdToSave}`, JSON.stringify(chatHistory));
                saveSessionIndex(sessions);
                populateSessions();
                showStatus("Session saved", false);
                
            } catch (e) {
                console.error("Error saving session:", e);
                showStatus("Error saving session", true);
            }
        }

        function handleLoadSession(sessionId) {
            if (sessionId === currentSessionId && chatHistory.length > 0) return;
            
            try {
                const historyJson = localStorage.getItem(`${SESSION_DATA_PREFIX}${sessionId}`);
                if (!historyJson) throw new Error("Session data not found");
                
                const loadedHistory = JSON.parse(historyJson);
                if (!Array.isArray(loadedHistory)) throw new Error("Invalid session data format");
                
                if (currentAbortController) {
                    currentAbortController.abort();
                }
                
                chatHistory = loadedHistory;
                currentSessionId = sessionId;
                clearStagedFiles();
                
                let maxId = -1;
                chatHistory.forEach(msg => {
                    if (msg.id && msg.id.startsWith('msg-')) {
                        const num = parseInt(msg.id.substring(4), 10);
                        if (!isNaN(num) && num > maxId) maxId = num;
                    }
                });
                messageCounter = maxId + 1;
                
                renderChatHistory();
                showStatus("Session loaded", false);
                populateSessions();
                scrollToBottom();
                resetSendButton();
                
                const lastAssistantMessage = chatHistory.slice().reverse().find(m => m.role === 'assistant');
                if (lastAssistantMessage && lastAssistantMessage.model) {
                    switchModel(lastAssistantMessage.model);
                }

            } catch (e) {
                console.error("Error loading session:", e);
                showStatus("Error loading session", true);
                startNewSession();
            }
        }

        function handleDeleteSession(sessionId) {
            const sessions = getSessionIndex();
            const sessionToDelete = sessions.find(s => s.id === sessionId);
            if (!sessionToDelete) return;
            
            if (!confirm(`Are you sure you want to delete session "${sessionToDelete.name}"? This cannot be undone.`)) return;
            
            try {
                localStorage.removeItem(`${SESSION_DATA_PREFIX}${sessionId}`);
                const updatedSessions = sessions.filter(s => s.id !== sessionId);
                saveSessionIndex(updatedSessions);
                
                if (currentSessionId === sessionId) {
                    startNewSession();
                }
                
                populateSessions();
                showStatus("Session deleted", false);
                
            } catch (e) {
                console.error("Error deleting session:", e);
                showStatus("Error deleting session", true);
            }
        }

        // Import/Export
        function handleExportAll() {
            const sessions = getSessionIndex();
            if (sessions.length === 0) {
                showStatus("No chats to export.", true);
                return;
            }
            
            const exportData = {
                version: "1.1",
                exportDate: new Date().toISOString(),
                sessions: []
            };
            
            sessions.forEach(sessionMeta => {
                const historyJson = localStorage.getItem(`${SESSION_DATA_PREFIX}${sessionMeta.id}`);
                if (historyJson) {
                    try {
                        const history = JSON.parse(historyJson);
                        exportData.sessions.push({
                            id: sessionMeta.id,
                            name: sessionMeta.name,
                            timestamp: sessionMeta.timestamp,
                            history: history
                        });
                    } catch (e) {
                        console.error(`Error parsing session ${sessionMeta.id} for export:`, e);
                    }
                }
            });
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `totum-chat-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus("All chats exported", false);
        }

        function handleImportChats(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target.result);
                    if (!importData.sessions || !Array.isArray(importData.sessions)) {
                        throw new Error("Invalid import file format");
                    }
                    
                    const existingSessions = getSessionIndex();
                    let importedCount = 0;
                    let skippedCount = 0;
                    
                    importData.sessions.forEach(sessionData => {
                        const newSessionId = sessionData.id || `${SESSION_DATA_PREFIX}${sessionData.timestamp || Date.now()}-${Math.random().toString(36).slice(2,9)}`;
                        if (existingSessions.find(s => s.id === newSessionId)) {
                            skippedCount++;
                            return;
                        }

                        existingSessions.push({
                            id: newSessionId,
                            name: sessionData.name || `Imported Chat ${importedCount + 1}`,
                            timestamp: sessionData.timestamp || Date.now()
                        });
                        
                        (sessionData.history || []).forEach((msg, idx) => {
                            if (!msg.id) msg.id = `msg-imported-${idx}-${Date.now()}`;
                        });

                        localStorage.setItem(`${SESSION_DATA_PREFIX}${newSessionId}`, JSON.stringify(sessionData.history || []));
                        importedCount++;
                    });
                    
                    saveSessionIndex(existingSessions);
                    populateSessions();
                    let importStatusMsg = `Imported ${importedCount} sessions.`;
                    if (skippedCount > 0) importStatusMsg += ` Skipped ${skippedCount}.`;
                    showStatus(importStatusMsg, false);
                    
                } catch (e) {
                    console.error("Import error:", e);
                    showStatus(`Error importing file: ${e.message}`, true);
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        // UI Helpers
        function updateSendButtonState() {
            if (currentAbortController) {
                elements.sendButton.disabled = false;
                return;
            }
            
            const hasInput = elements.chatInput.value.trim().length > 0 || stagedFiles.length > 0;
            let canSend = false;
            
            if (currentModelType === 'gemini') {
                const hasApiKey = elements.geminiApiKey.value.trim().length > 0;
                const hasModel = elements.geminiModelSelect.value.length > 0;
                canSend = hasApiKey && hasModel && hasInput;
            } else if (currentModelType === 'llama') {
                const hasValidUrl = isValidHttpUrl(elements.llamaServerUrl.value.trim());
                canSend = hasValidUrl && hasInput;
            } else if (currentModelType === 'openai') {
                const hasApiKey = elements.openaiApiKey.value.trim().length > 0;
                const hasModel = elements.openaiModelSelect.value.length > 0;
                canSend = hasApiKey && hasModel && hasInput;
            }
            
            elements.sendButton.disabled = !canSend;
        }

        function updateSessionButtonState() {
            elements.saveSessionBtn.disabled = chatHistory.length === 0 || currentAbortController !== null;
        }

        async function updateTokenCount() {
            if (currentModelType !== 'gemini' || chatHistory.length === 0) {
                elements.tokenCountValue.textContent = '0';
                return;
            }
            
            const apiKey = elements.geminiApiKey.value.trim();
            const model = elements.geminiModelSelect.value;
            
            if (!apiKey || !model) {
                elements.tokenCountValue.textContent = '0';
                return;
            }
            
            elements.tokenCountValue.textContent = '...';
            
            try {
                const contentsForApi = chatHistory.map(msg => {
                    const role = msg.role === 'user' ? 'user' : 'model';
                    const parts = [{ text: msg.displayContent || msg.content }];
                    if (msg.role === 'user' && msg.fileInfo && Array.isArray(msg.fileInfo)) {
                        msg.fileInfo.forEach(file => {
                            if (file.data && file.data.startsWith('data:')) {
                                const [header, base64Data] = file.data.split(',');
                                const mimeType = header.match(/:(.*?);/)?.[1] || file.type;
                                if (base64Data && mimeType) {
                                    parts.push({
                                        inlineData: {
                                            mimeType: mimeType,
                                            data: base64Data
                                        }
                                    });
                                }
                            }
                        });
                    }
                    return { role, parts };
                });
                
                const response = await fetch(
                    `${GEMINI_API_BASE}${model}:countTokens?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    elements.tokenCountValue.textContent = data.totalTokens || '0';
                } else {
                    elements.tokenCountValue.textContent = 'N/A';
                    console.warn("Token count failed:", await response.text());
                }
            } catch (error) {
                elements.tokenCountValue.textContent = 'N/A';
                console.warn("Token count error:", error);
            }
        }

        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        function scrollToBottom() {
            requestAnimationFrame(() => {
                elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
            });
        }

        function showStatus(message, isError = false, duration = 3000) {
            elements.statusBar.textContent = message;
            elements.statusBar.className = `text-${isError ? 'danger' : 'success'}`;
            
            if (message && duration > 0) {
                setTimeout(() => {
                    if (elements.statusBar.textContent === message) {
                        elements.statusBar.textContent = '';
                        elements.statusBar.className = 'text-muted';
                    }
                }, duration);
            }
        }

        // Theme Management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            setTheme(savedTheme);
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-bs-theme', theme);
            
            const isDark = theme === 'dark';
            document.getElementById('highlight-theme').href = 
                `https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github${isDark ? '-dark' : ''}.min.css`;
            elements.themeSwitcher.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme') || 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }

        // Config Management
        function loadConfig() {
            const shouldRemember = localStorage.getItem('rememberUnifiedConfig') === 'true';
            elements.rememberConfig.checked = shouldRemember;
            
            currentModelType = localStorage.getItem('unifiedModelType') || 'gemini';

            if (shouldRemember) {
                elements.geminiApiKey.value = localStorage.getItem('unifiedGeminiApiKey') || '';
                elements.llamaServerUrl.value = localStorage.getItem('unifiedLlamaServerUrl') || 'http://127.0.0.1:8080';
                elements.openaiApiKey.value = localStorage.getItem('unifiedOpenAIApiKey') || '';
                elements.temperature.value = localStorage.getItem('unifiedTemperature') || '0.7';
                elements.maxTokens.value = localStorage.getItem('unifiedMaxTokens') || '2048';
                elements.topP.value = localStorage.getItem('unifiedTopP') || '0.95';
                elements.topK.value = localStorage.getItem('unifiedTopK') || '40';
                elements.stopSequences.value = localStorage.getItem('unifiedStopSequences') || 'USER:, \\nUSER:, <|user|>';
            }
        }

        function saveConfig() {
            localStorage.setItem('unifiedModelType', currentModelType);
            if (!elements.rememberConfig.checked) return;
            
            localStorage.setItem('unifiedGeminiApiKey', elements.geminiApiKey.value);
            localStorage.setItem('unifiedLlamaServerUrl', elements.llamaServerUrl.value);
            localStorage.setItem('unifiedOpenAIApiKey', elements.openaiApiKey.value);
            localStorage.setItem('unifiedTemperature', elements.temperature.value);
            localStorage.setItem('unifiedMaxTokens', elements.maxTokens.value);
            localStorage.setItem('unifiedTopP', elements.topP.value);
            localStorage.setItem('unifiedTopK', elements.topK.value);
            localStorage.setItem('unifiedStopSequences', elements.stopSequences.value);
        }

        function handleRememberConfigChange() {
            localStorage.setItem('rememberUnifiedConfig', elements.rememberConfig.checked);
            
            if (elements.rememberConfig.checked) {
                saveConfig();
            } else {
                const keysToRemove = [
                    'unifiedGeminiApiKey', 'unifiedLlamaServerUrl', 'unifiedOpenAIApiKey',
                    'unifiedTemperature', 'unifiedMaxTokens', 'unifiedTopP', 'unifiedTopK', 'unifiedStopSequences'
                ];
                keysToRemove.forEach(key => localStorage.removeItem(key));
            }
        }

        function handleGeminiApiKeyInput() {
            if (elements.geminiApiKey.value.trim()) {
                fetchGeminiModels();
            } else {
                updateModelDropdown(elements.geminiModelSelect, [], "-- Enter API Key First --");
                geminiModelsLoaded = false;
            }
            saveConfig();
        }

        function handleOpenAIApiKeyInput() {
            if (elements.openaiApiKey.value.trim()) {
                fetchOpenAIModels();
            } else {
                updateModelDropdown(elements.openaiModelSelect, [], "-- Enter API Key First --");
                openaiModelsLoaded = false;
            }
            saveConfig();
        }

        // Utility Functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function isValidHttpUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === "http:" || url.protocol === "https:";
            } catch (_) {
                return false;
            }
        }

        // Initialize the app
        initialize();
    </script>
</body>
</html>
                
