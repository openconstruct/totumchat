<!DOCTYPE html>
<<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Totum Chat</title>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="highlight-theme">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        :root {
            --bg: #212121;
            --bg-light: #2a2a2a;
            --text: #ececf1;
            --text-dim: #a9a9a9;
            --border: #444;
            --primary: #10a37f; /* Llama color */
            --danger: #ef4444;
            --gemini: #4285f4;
            --openai: #41A58F; /* OpenAI color */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* Layout */
        .app-container { display: flex; height: 100vh; }
        
        .sidebar {
            width: 260px;
            background: #171717;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 12px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Buttons */
        button {
            background: var(--bg-light);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover { background: #3a3a3a; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { background: var(--primary); border-color: var(--primary); }
        .btn-primary:hover { background: #0d8f6f; }
        .btn-danger { background: var(--danger); border-color: var(--danger); }

        /* Inputs */
        input, select, textarea {
            background: var(--bg-light);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-family: inherit;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Sidebar */
        .new-chat-btn {
            width: 100%;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .new-chat-btn::before { content: '+'; font-size: 18px; }

        .sessions-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .session-item {
            padding: 8px 12px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-item:hover, .session-item.active { background: var(--bg-light); }
        .session-item .delete-btn { opacity: 0; background: none; border: none; color: var(--danger); }
        .session-item:hover .delete-btn { opacity: 1; }

        .save-session-btn { width: 100%; margin-bottom: 12px; }

        .model-type-toggle {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .model-type-btn {
            flex: 1;
            padding: 6px 8px;
            font-size: 13px;
        }

        .model-type-btn.active.gemini { background: var(--gemini); border-color: var(--gemini); }
        .model-type-btn.active.llama { background: var(--primary); border-color: var(--primary); }
        .model-type-btn.active.openai { background: var(--openai); border-color: var(--openai); }


        .config-input {
            width: 100%;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .sidebar-actions {
            display: flex;
            gap: 8px;
        }

        .sidebar-actions button { flex: 1; }

        /* Chat */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
        }

        .chat-message {
            padding: 24px 0;
            border-bottom: 1px solid var(--border);
        }

        .chat-message:last-child { border-bottom: none; }

        .message-content {
            max-width: 768px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            gap: 24px;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
            flex-shrink: 0;
        }

        .user-message .message-avatar { background: var(--primary); color: white; }
        .assistant-message .message-avatar { background: var(--bg-light); }
        .assistant-message.gemini .message-avatar { background: var(--gemini); color: white; }
        .assistant-message.llama .message-avatar { background: var(--primary); color: white; }
        .assistant-message.openai .message-avatar { background: var(--openai); color: white; }


        .message-body {
            flex: 1;
            min-width: 0;
        }

        .message-body h1, .message-body h2, .message-body h3 {
            margin: 1em 0 0.5em 0;
        }

        .message-body p { margin-bottom: 1em; }
        .message-body p:last-child { margin-bottom: 0; }
        .message-body ul, .message-body ol { margin: 0 0 1em 24px; }
        .message-body li { margin-bottom: 0.5em; }

        .message-body code:not(pre code) {
            background: #1a1a1a;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.875em;
        }

        .message-body pre {
            position: relative;
            background: #1a1a1a;
            border-radius: 6px;
            padding: 16px;
            padding-top: 40px;
            overflow-x: auto;
            margin: 1em 0;
        }

        .message-body blockquote {
            border-left: 3px solid var(--border);
            padding-left: 16px;
            margin: 1em 0;
            color: var(--text-dim);
        }

        /* Code Actions */
        .code-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
        }

        .code-action-button {
            padding: 4px 8px;
            font-size: 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            opacity: 0.8;
        }

        .code-action-button:hover { opacity: 1; }
        .code-action-button.copied { background: var(--primary); border-color: var(--primary); }

        /* Chat Input */
        .chat-input-container {
            border-top: 1px solid var(--border);
            padding: 16px 0;
        }

        .chat-input-wrapper {
            max-width: 768px;
            margin: 0 auto;
            padding: 0 24px;
        }

        .input-area {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
        }

        .input-area:focus-within { border-color: var(--primary); }

        .staged-files {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        .staged-file-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #303030;
            border-radius: 4px;
            font-size: 13px;
        }

        .remove-file-button {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 0 2px;
        }

        .remove-file-button:hover { color: var(--danger); }

        .input-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-input {
            flex: 1;
            background: none;
            border: none;
            color: var(--text);
            font-size: 15px;
            resize: none;
            outline: none;
            min-height: 24px;
            max-height: 200px;
            overflow-y: auto;
            font-family: inherit;
            line-height: 1.5;
        }

        .input-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-upload-label {
            cursor: pointer;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .file-upload-label:hover { color: var(--text); background: #303030; }
        .file-upload-label svg { width: 20px; height: 20px; }

        .send-button {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .send-button:hover:not(:disabled) { background: #0d8f6f; }
        .send-button.stop-button { background: var(--danger); border-color: var(--danger); }

        /* Status & Misc */
        .status-bar {
            padding: 8px 24px;
            text-align: center;
            font-size: 13px;
            color: var(--text-dim);
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-bar.error { color: var(--danger); }
        .status-bar.info { color: var(--primary); }

        .token-counter {
            font-size: 12px;
            color: var(--text-dim);
            text-align: center;
            margin-top: 4px;
        }

        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: var(--text-dim);
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 8px;
            color: var(--text);
        }

        .streaming-indicator {
            animation: blink 1s step-start infinite;
            opacity: 0.7;
        }

        @keyframes blink { 50% { opacity: 0; } }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active { opacity: 1; visibility: visible; }

        .modal {
            background: var(--bg);
            border-radius: 12px;
            padding: 24px;
            max-width: 480px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-title { font-size: 18px; font-weight: 600; }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 24px;
            padding: 4px;
        }

        .modal-close:hover { color: var(--text); }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .settings-group input, .settings-group select {
            width: 100%;
        }

        .settings-group small {
            display: block;
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-dim);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .api-key-warning {
            font-size: 12px;
            color: #f59e0b;
            margin-top: 6px;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -260px;
                height: 100%;
                z-index: 100;
                transition: left 0.3s;
            }
            .sidebar.open { left: 0; }
            .mobile-menu-btn {
                position: fixed;
                top: 16px; left: 16px;
                z-index: 101;
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                padding: 8px;
                display: flex;
            }
            .message-content, .chat-input-wrapper { padding: 0 16px; }
        }

        @media (min-width: 769px) {
            .mobile-menu-btn { display: none; }
        }

        input[type="file"] { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Mobile Menu Button -->
        <button class="mobile-menu-btn" id="mobileMenuBtn">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12h18M3 6h18M3 18h18"></path>
            </svg>
        </button>

        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" id="newChatBtn">New chat</button>
            </div>
            
            <div class="sessions-list" id="sessionsList">
                <!-- Sessions will be populated here -->
            </div>

            <button class="save-session-btn" id="saveSessionBtn">
                <span style="font-size: 18px; font-weight: 400;">💾</span>
                Save chat
            </button>

            <div class="sidebar-footer">
                <div class="model-selector">
                    <div class="model-type-toggle">
                        <button class="model-type-btn gemini" id="geminiBtn">Gemini</button>
                        <button class="model-type-btn llama" id="llamaBtn">Llama</button>
                        <button class="model-type-btn openai" id="openaiBtn">OpenAI</button>
                    </div>
                    
                    <!-- Gemini Config -->
                    <div id="geminiConfig" style="display: none;">
                        <input type="password" class="config-input" id="geminiApiKey" placeholder="Google AI Studio API Key">
                        <select class="config-input" id="geminiModelSelect" disabled>
                            <option value="">-- Enter API Key First --</option>
                        </select>
                    </div>
                    
                    <!-- Llama Config -->
                    <div id="llamaConfig" style="display: none;">
                        <input type="url" class="config-input" id="llamaServerUrl" placeholder="Server URL (e.g., http://127.0.0.1:8080)" value="http://127.0.0.1:8080">
                    </div>

                    <!-- OpenAI Config -->
                    <div id="openaiConfig" style="display: none;">
                        <input type="password" class="config-input" id="openaiApiKey" placeholder="OpenAI API Key">
                        <select class="config-input" id="openaiModelSelect" disabled>
                            <option value="">-- Enter API Key First --</option>
                        </select>
                    </div>
                </div>

                <div class="sidebar-actions">
                    <button id="settingsBtn">Settings</button>
                    <button id="themeSwitcher">🌙</button>
                    <button id="importExportBtn">📁</button>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Chat Container -->
            <div class="chat-container" id="chatContainer">
                <div class="empty-state">
                    <h2>Totum Chat</h2>
                    <p>Chat with Gemini, Llama, or OpenAI models</p>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <div class="input-area">
                        <div class="staged-files" id="stagedFilesArea" style="display: none;">
                            <!-- Staged files will appear here -->
                        </div>
                        <div class="input-row">
                            <textarea 
                                class="chat-input" 
                                id="chatInput" 
                                placeholder="Message..."
                                rows="1"
                            ></textarea>
                            <div class="input-actions">
                                <label for="fileInput" class="file-upload-label" title="Attach files">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                                    </svg>
                                </label>
                                <input type="file" id="fileInput" multiple accept="text/*,image/*,application/pdf,audio/*,video/*,.md,.py,.js,.html,.css,.json,.xml,.csv,.log">
                                <button class="send-button" id="sendButton">
                                    <span>Send</span>
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="22" y1="2" x2="11" y2="13"></line>
                                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="status-bar" id="statusBar"></div>
                    <div class="token-counter" id="tokenCounter" style="display: none;">
                        <span id="tokenCountValue">0</span> tokens (Gemini only)
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="closeSettings">&times;</button>
            </div>
            
            <div class="settings-group">
                <label for="temperature">Temperature</label>
                <input type="number" id="temperature" min="0" max="2" step="0.1" value="0.7">
                <small>Controls randomness. Higher values make output more random.</small>
            </div>

            <div class="settings-group">
                <label for="maxTokens">Max Tokens</label>
                <input type="number" id="maxTokens" min="1" step="1" value="2048">
                <small>Maximum number of tokens to generate.</small>
            </div>

            <div class="settings-group">
                <label for="topP">Top P</label>
                <input type="number" id="topP" min="0" max="1" step="0.01" value="0.95">
                <small>Nucleus sampling parameter.</small>
            </div>

            <div class="settings-group">
                <label for="topK">Top K (Llama/Gemini)</label>
                <input type="number" id="topK" min="1" step="1" value="40">
                <small>Top-k sampling parameter. Not used by OpenAI Chat API.</small>
            </div>

            <div class="settings-group" id="modelStopSequences">
                <label for="stopSequences">Stop Sequences</label>
                <input type="text" id="stopSequences" value="USER:, \nUSER:, <|user|>">
                <small>Comma-separated strings to stop generation.</small>
            </div>

            <div class="settings-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="rememberConfig">
                    <label for="rememberConfig">Remember API Keys & Server URLs</label>
                </div>
                <div class="api-key-warning">
                    ⚠️ Storing API keys in browser storage is insecure for shared devices.
                </div>
            </div>
        </div>
    </div>

    <!-- Import/Export Modal -->
    <div class="modal-overlay" id="importExportModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Import/Export Chats</h3>
                <button class="modal-close" id="closeImportExport">&times;</button>
            </div>
            
            <div class="settings-group">
                <button class="send-button" style="width: 100%; margin-bottom: 12px;" id="exportAllBtn">
                    Export All Chats
                </button>
                <button class="send-button" style="width: 100%;" id="importChatsBtn">
                    Import Chats
                </button>
                <input type="file" id="importFileInput" accept=".json">
            </div>
        </div>
    </div>

    <script>
        'use strict';

        // Constants
        const SESSION_INDEX_KEY = 'unifiedChatIndex';
        const SESSION_DATA_PREFIX = 'unifiedChatSession_';
        const MAX_TEXT_FILE_EMBED_SIZE = 200 * 1024; // For Llama text embedding
        const GEMINI_API_BASE = "https://generativelanguage.googleapis.com/v1beta/";
        const OPENAI_API_BASE = "https://api.openai.com/v1/";


        // State
        let chatHistory = [];
        let currentSessionId = null;
        let currentAbortController = null;
        let messageCounter = 0;
        let stagedFiles = [];
        let currentModelType = 'gemini'; // 'gemini', 'llama', or 'openai'
        let geminiModelsLoaded = false;
        let openaiModelsLoaded = false;


        // DOM Elements
        const elements = {
            // Sidebar
            sidebar: document.getElementById('sidebar'),
            mobileMenuBtn: document.getElementById('mobileMenuBtn'),
            newChatBtn: document.getElementById('newChatBtn'),
            sessionsList: document.getElementById('sessionsList'),
            saveSessionBtn: document.getElementById('saveSessionBtn'),
            
            // Model Config
            geminiBtn: document.getElementById('geminiBtn'),
            llamaBtn: document.getElementById('llamaBtn'),
            openaiBtn: document.getElementById('openaiBtn'),

            geminiConfig: document.getElementById('geminiConfig'),
            llamaConfig: document.getElementById('llamaConfig'),
            openaiConfig: document.getElementById('openaiConfig'),
            
            geminiApiKey: document.getElementById('geminiApiKey'),
            geminiModelSelect: document.getElementById('geminiModelSelect'),
            
            llamaServerUrl: document.getElementById('llamaServerUrl'),

            openaiApiKey: document.getElementById('openaiApiKey'),
            openaiModelSelect: document.getElementById('openaiModelSelect'),
            
            // Settings
            settingsBtn: document.getElementById('settingsBtn'),
            settingsModal: document.getElementById('settingsModal'),
            closeSettings: document.getElementById('closeSettings'),
            themeSwitcher: document.getElementById('themeSwitcher'),
            temperature: document.getElementById('temperature'),
            maxTokens: document.getElementById('maxTokens'),
            topP: document.getElementById('topP'),
            topK: document.getElementById('topK'),
            stopSequences: document.getElementById('stopSequences'),
            modelStopSequences: document.getElementById('modelStopSequences'), // Changed from llamaStopSequences
            rememberConfig: document.getElementById('rememberConfig'),
            
            // Import/Export
            importExportBtn: document.getElementById('importExportBtn'),
            importExportModal: document.getElementById('importExportModal'),
            closeImportExport: document.getElementById('closeImportExport'),
            exportAllBtn: document.getElementById('exportAllBtn'),
            importChatsBtn: document.getElementById('importChatsBtn'),
            importFileInput: document.getElementById('importFileInput'),
            
            // Chat
            chatContainer: document.getElementById('chatContainer'),
            chatInput: document.getElementById('chatInput'),
            sendButton: document.getElementById('sendButton'),
            fileInput: document.getElementById('fileInput'),
            stagedFilesArea: document.getElementById('stagedFilesArea'),
            statusBar: document.getElementById('statusBar'),
            tokenCounter: document.getElementById('tokenCounter'),
            tokenCountValue: document.getElementById('tokenCountValue')
        };

        // Initialize
        function initialize() {
            loadConfig();
            setupEventListeners();
            initializeTheme();
            configureMarked();
            populateSessions();
            switchModel(currentModelType); // Applies loaded or default model
            updateSendButtonState();
        }

        function setupEventListeners() {
            // Sidebar
            elements.mobileMenuBtn.addEventListener('click', toggleMobileSidebar);
            elements.newChatBtn.addEventListener('click', startNewSession);
            elements.saveSessionBtn.addEventListener('click', handleSaveSession);
            
            // Model Selection
            elements.geminiBtn.addEventListener('click', () => switchModel('gemini'));
            elements.llamaBtn.addEventListener('click', () => switchModel('llama'));
            elements.openaiBtn.addEventListener('click', () => switchModel('openai'));
            
            // Gemini Config
            elements.geminiApiKey.addEventListener('input', handleGeminiApiKeyInput);
            elements.geminiModelSelect.addEventListener('change', updateSendButtonState);
            
            // Llama Config
            elements.llamaServerUrl.addEventListener('input', handleLlamaServerInput);

            // OpenAI Config
            elements.openaiApiKey.addEventListener('input', handleOpenAIApiKeyInput);
            elements.openaiModelSelect.addEventListener('change', updateSendButtonState);
            
            // Settings
            elements.settingsBtn.addEventListener('click', () => elements.settingsModal.classList.add('active'));
            elements.closeSettings.addEventListener('click', () => elements.settingsModal.classList.remove('active'));
            elements.settingsModal.addEventListener('click', (e) => {
                if (e.target === elements.settingsModal) elements.settingsModal.classList.remove('active');
            });
            elements.rememberConfig.addEventListener('change', handleRememberConfigChange);
            
            // Import/Export
            elements.importExportBtn.addEventListener('click', () => elements.importExportModal.classList.add('active'));
            elements.closeImportExport.addEventListener('click', () => elements.importExportModal.classList.remove('active'));
            elements.exportAllBtn.addEventListener('click', handleExportAll);
            elements.importChatsBtn.addEventListener('click', () => elements.importFileInput.click());
            elements.importFileInput.addEventListener('change', handleImportChats);
            
            // Theme
            elements.themeSwitcher.addEventListener('click', toggleTheme);
            
            // Chat Input
            elements.sendButton.addEventListener('click', handleSendPrompt);
            elements.chatInput.addEventListener('input', () => {
                updateSendButtonState();
                autoResizeTextarea(elements.chatInput);
            });
            elements.chatInput.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                    event.preventDefault();
                    if (!elements.sendButton.disabled && elements.sendButton.textContent.includes('Send')) {
                        handleSendPrompt();
                    }
                }
            });
            
            // File Input
            elements.fileInput.addEventListener('change', handleFileSelection);
            elements.stagedFilesArea.addEventListener('click', handleRemoveStagedFile);
            
            // Chat Container - Code buttons
            elements.chatContainer.addEventListener('click', function(event) {
                if (event.target.classList.contains('copy-code-button')) {
                    handleCopyCodeClick(event.target);
                } else if (event.target.classList.contains('download-code-button')) {
                    handleDownloadCodeClick(event.target);
                }
            });
            
            // Sessions List
            elements.sessionsList.addEventListener('click', function(event) {
                const sessionItem = event.target.closest('.session-item');
                const deleteBtn = event.target.closest('.delete-btn');
                
                if (deleteBtn && sessionItem) {
                    event.stopPropagation();
                    handleDeleteSession(sessionItem.dataset.sessionId);
                } else if (sessionItem) {
                    handleLoadSession(sessionItem.dataset.sessionId);
                    closeMobileSidebar();
                }
            });
        }

        function configureMarked() {
            marked.setOptions({
                highlight: function(code, lang) {
                    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                    try {
                        const result = hljs.highlight(code, { language, ignoreIllegals: true });
                        return result.value;
                    } catch (e) {
                        console.warn("Highlight.js error:", e);
                        return escapeHtml(code);
                    }
                },
                gfm: true,
                breaks: true,
                langPrefix: 'hljs language-',
            });
        }

        // Model Management
        function switchModel(modelType) {
            currentModelType = modelType;
            
            elements.geminiBtn.classList.remove('active');
            elements.llamaBtn.classList.remove('active');
            elements.openaiBtn.classList.remove('active');

            elements.geminiConfig.style.display = 'none';
            elements.llamaConfig.style.display = 'none';
            elements.openaiConfig.style.display = 'none';
            
            elements.tokenCounter.style.display = 'none'; // Default to hide
            elements.modelStopSequences.style.display = 'none'; // Default to hide


            if (modelType === 'gemini') {
                elements.geminiBtn.classList.add('active');
                elements.geminiConfig.style.display = 'block';
                elements.tokenCounter.style.display = 'block'; // Gemini has token counting
                
                if (elements.geminiApiKey.value.trim() && !geminiModelsLoaded) {
                    fetchGeminiModels();
                }
            } else if (modelType === 'llama') {
                elements.llamaBtn.classList.add('active');
                elements.llamaConfig.style.display = 'block';
                elements.modelStopSequences.style.display = 'block';
            } else if (modelType === 'openai') {
                elements.openaiBtn.classList.add('active');
                elements.openaiConfig.style.display = 'block';
                elements.modelStopSequences.style.display = 'block';
                // Token counter not shown for OpenAI for now.
                
                if (elements.openaiApiKey.value.trim() && !openaiModelsLoaded) {
                    fetchOpenAIModels();
                }
            }
            
            updateSendButtonState();
            saveConfig();
        }

        // Gemini API Functions (existing)
        let geminiApiKeyDebounceTimer;
        function handleGeminiApiKeyInput() {
            clearTimeout(geminiApiKeyDebounceTimer);
            geminiApiKeyDebounceTimer = setTimeout(() => {
                if (elements.geminiApiKey.value.trim()) {
                    fetchGeminiModels();
                } else {
                    updateGeminiModelDropdown([], "-- Enter API Key First --");
                    geminiModelsLoaded = false;
                }
                saveConfig(); 
            }, 500);
        }

        async function fetchGeminiModels() {
            const apiKey = elements.geminiApiKey.value.trim();
            if (!apiKey) return;
            
            geminiModelsLoaded = false;
            updateGeminiModelDropdown([], "Loading...");
            elements.geminiModelSelect.disabled = true;
            
            try {
                const response = await fetch(`${GEMINI_API_BASE}models?key=${apiKey}`);
                if (!response.ok) throw new Error(`Failed to list models: ${response.status}`);
                
                const data = await response.json();
                const compatibleModels = (data.models || [])
                    .filter(model => model.name.startsWith('models/') && 
                            model.supportedGenerationMethods?.includes('generateContent'))
                    .sort((a, b) => (a.displayName || a.name).localeCompare(b.displayName || b.name));
                
                if (compatibleModels.length > 0) {
                    updateGeminiModelDropdown(compatibleModels);
                    geminiModelsLoaded = true;
                } else {
                    updateGeminiModelDropdown([], "No compatible models found.");
                }
            } catch (error) {
                console.error("Fetch Gemini Models Error:", error);
                showStatus(`Error: ${error.message}`, true);
                updateGeminiModelDropdown([], "Error loading models");
            }
        }

        function updateGeminiModelDropdown(models, placeholderText = "-- Select a Model --") {
            const previousValue = elements.geminiModelSelect.value;
            elements.geminiModelSelect.innerHTML = '';
            
            const placeholder = document.createElement('option');
            placeholder.value = "";
            placeholder.textContent = placeholderText;
            placeholder.disabled = true;
            placeholder.selected = true;
            elements.geminiModelSelect.appendChild(placeholder);
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                let displayName = model.displayName || model.name.split('/').pop();
                if (model.name.includes('gemini-1.5-pro')) displayName += ' (Multimodal)';
                option.textContent = displayName;
                elements.geminiModelSelect.appendChild(option);
                
                if (model.name === previousValue || 
                    (!previousValue && model.name.includes('gemini-1.5-pro-latest'))) { // Prefer latest pro
                    option.selected = true;
                    placeholder.selected = false;
                }
            });
            
            elements.geminiModelSelect.disabled = models.length === 0;
            updateSendButtonState();
        }

        // Llama Server Functions (existing)
        let llamaServerDebounceTimer;
        function handleLlamaServerInput() {
            clearTimeout(llamaServerDebounceTimer);
            llamaServerDebounceTimer = setTimeout(() => {
                saveConfig();
                updateSendButtonState();
            }, 500);
        }

        // OpenAI API Functions (new)
        let openaiApiKeyDebounceTimer;
        function handleOpenAIApiKeyInput() {
            clearTimeout(openaiApiKeyDebounceTimer);
            openaiApiKeyDebounceTimer = setTimeout(() => {
                if (elements.openaiApiKey.value.trim()) {
                    fetchOpenAIModels();
                } else {
                    updateOpenAIModelDropdown([], "-- Enter API Key First --");
                    openaiModelsLoaded = false;
                }
                saveConfig();
            }, 500);
        }

        async function fetchOpenAIModels() {
            const apiKey = elements.openaiApiKey.value.trim();
            if (!apiKey) return;

            openaiModelsLoaded = false;
            updateOpenAIModelDropdown([], "Loading...");
            elements.openaiModelSelect.disabled = true;

            try {
                const response = await fetch(`${OPENAI_API_BASE}models`, {
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });
                if (!response.ok) throw new Error(`Failed to list models: ${response.status}`);

                const data = await response.json();
                // Filter for chat models (typically containing "gpt") and sort them
                // Prioritize newer models like gpt-4o, gpt-4-turbo
                const compatibleModels = (data.data || [])
                    .filter(model => model.id.includes('gpt-')) // Basic filter for GPT models
                    .sort((a, b) => {
                        // Simple sort: gpt-4o, gpt-4-turbo, gpt-4, gpt-3.5-turbo, then others
                        const order = ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'];
                        const aOrder = order.findIndex(p => a.id.startsWith(p));
                        const bOrder = order.findIndex(p => b.id.startsWith(p));
                        if (aOrder !== -1 && bOrder !== -1) return aOrder - bOrder;
                        if (aOrder !== -1) return -1;
                        if (bOrder !== -1) return 1;
                        return b.id.localeCompare(a.id); // Fallback to reverse alphabetical
                    });

                if (compatibleModels.length > 0) {
                    updateOpenAIModelDropdown(compatibleModels);
                    openaiModelsLoaded = true;
                } else {
                    updateOpenAIModelDropdown([], "No compatible models found.");
                }
            } catch (error) {
                console.error("Fetch OpenAI Models Error:", error);
                showStatus(`OpenAI Error: ${error.message}`, true);
                updateOpenAIModelDropdown([], "Error loading models");
            }
        }

        function updateOpenAIModelDropdown(models, placeholderText = "-- Select a Model --") {
            const previousValue = elements.openaiModelSelect.value;
            elements.openaiModelSelect.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = "";
            placeholder.textContent = placeholderText;
            placeholder.disabled = true;
            placeholder.selected = true;
            elements.openaiModelSelect.appendChild(placeholder);

            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.id;
                elements.openaiModelSelect.appendChild(option);

                if (model.id === previousValue || 
                    (!previousValue && model.id.startsWith('gpt-4o'))) { // Default to gpt-4o if available
                    option.selected = true;
                    placeholder.selected = false;
                }
            });

            elements.openaiModelSelect.disabled = models.length === 0;
            updateSendButtonState();
        }


        // Send Message
        async function handleSendPrompt() {
            if (currentAbortController) {
                handleStopGeneration();
                return;
            }

            const promptText = elements.chatInput.value.trim();
            
            if (!promptText && stagedFiles.length === 0) {
                showStatus("Message cannot be empty", true);
                return;
            }

            currentAbortController = new AbortController();
            elements.sendButton.innerHTML = '<span>Stop</span>';
            elements.sendButton.classList.add('stop-button');
            elements.chatInput.disabled = true;

            let userContentForHistory = promptText; // This is what's stored for display in history
            let fileInfoForHistory = null;
            
            if (stagedFiles.length > 0) {
                fileInfoForHistory = stagedFiles.map(f => ({
                    name: f.name,
                    type: f.type,
                    // Store the content (DataURL or text) with the message for OpenAI/Gemini to use
                    // Llama will re-process this for embedding its text files
                    data: f.content 
                }));
            }
            
            const userMessageId = `msg-${messageCounter++}`;
            const userMessage = {
                id: userMessageId,
                role: 'user',
                content: userContentForHistory, // Text part of the user's message
                fileInfo: fileInfoForHistory,  // Attached files information
                timestamp: new Date(),
                model: currentModelType,
                displayContent: promptText // Explicitly for display if content gets modified
            };
            
            chatHistory.push(userMessage);
            renderChatHistory();
            scrollToBottom();
            
            elements.chatInput.value = '';
            autoResizeTextarea(elements.chatInput);
            clearStagedFiles();
            
            const assistantMessageId = `msg-${messageCounter++}`;
            const assistantMessage = {
                id: assistantMessageId,
                role: 'assistant',
                content: '',
                timestamp: new Date(),
                model: currentModelType
            };
            chatHistory.push(assistantMessage);
            renderChatHistory(); // Render the placeholder for assistant
            
            try {
                if (currentModelType === 'gemini') {
                    await sendToGemini(assistantMessage);
                } else if (currentModelType === 'llama') {
                    // Llama needs special handling for its prompt string with embedded files
                    let llamaUserContent = promptText;
                    if (stagedFiles.length > 0) {
                        let fileInfoForPrompt = "Attached Files:\n";
                        stagedFiles.forEach(fileData => {
                            fileInfoForPrompt += `[File: ${fileData.name} (${fileData.type})]\n`;
                            // Llama expects plain text for text files
                            if (fileData.type.startsWith('text/') && typeof fileData.content === 'string') {
                                if (fileData.content.startsWith('data:')) { // If it's a DataURL
                                    try {
                                        const base64Decoded = atob(fileData.content.split(',')[1]);
                                        const textContent = decodeURIComponent(escape(base64Decoded));
                                        if (textContent.length < MAX_TEXT_FILE_EMBED_SIZE) {
                                            fileInfoForPrompt += `Content:\n---\n${textContent}\n---\n`;
                                        } else {
                                            fileInfoForPrompt += `Content: [File too large to embed: ${textContent.length} bytes]\n`;
                                        }
                                    } catch (e) {
                                        console.error("Error decoding DataURL for Llama text file:", e);
                                        fileInfoForPrompt += `Content: [Error decoding file for embedding]\n`;
                                    }
                                } else { // Assumed to be plain text already
                                     if (fileData.content.length < MAX_TEXT_FILE_EMBED_SIZE) {
                                        fileInfoForPrompt += `Content:\n---\n${fileData.content}\n---\n`;
                                    } else {
                                        fileInfoForPrompt += `Content: [File too large to embed: ${fileData.content.length} bytes]\n`;
                                    }
                                }
                            }
                        });
                        fileInfoForPrompt += "\nUser Message:\n";
                        llamaUserContent = fileInfoForPrompt + promptText;
                    }
                    // Modify the user message *content* specifically for Llama's API call format
                    // The chatHistory userMessage.content remains the original promptText for consistency
                    await sendToLlama(assistantMessage, llamaUserContent); 
                } else if (currentModelType === 'openai') {
                    await sendToOpenAI(assistantMessage);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Send error:", error);
                    showStatus(`Error: ${error.message}`, true);
                    const index = chatHistory.findIndex(m => m.id === assistantMessageId);
                    if (index > -1 && chatHistory[index].content === '') {
                        chatHistory.splice(index, 1);
                        renderChatHistory();
                    }
                }
            } finally {
                resetSendButton();
                if (currentModelType === 'gemini') updateTokenCount(); // Only for Gemini
            }
        }

        async function sendToGemini(assistantMessage) {
            const apiKey = elements.geminiApiKey.value.trim();
            const model = elements.geminiModelSelect.value;
            
            showStatus("Generating response (Gemini)...", false);
            
            const contentsForApi = chatHistory.slice(0, -1).map(msg => { // Exclude the current empty assistant message
                const role = msg.role === 'user' ? 'user' : 'model';
                const parts = [{ text: msg.displayContent || msg.content }];
                
                if (msg.role === 'user' && msg.fileInfo && Array.isArray(msg.fileInfo)) {
                    msg.fileInfo.forEach(file => {
                        if (file.data && file.data.startsWith('data:')) { // Expects DataURL
                            const [header, base64Data] = file.data.split(',');
                            const mimeType = header.match(/:(.*?);/)?.[1] || file.type;
                            if (base64Data && mimeType) {
                                parts.push({
                                    inlineData: {
                                        mimeType: mimeType,
                                        data: base64Data
                                    }
                                });
                            }
                        }
                    });
                }
                return { role, parts };
            });
            
            const apiUrl = `${GEMINI_API_BASE}${model}:streamGenerateContent?key=${apiKey}&alt=sse`;
            const requestBody = {
                contents: contentsForApi,
                generationConfig: {
                    temperature: parseFloat(elements.temperature.value),
                    maxOutputTokens: parseInt(elements.maxTokens.value, 10),
                    topP: parseFloat(elements.topP.value),
                    topK: parseInt(elements.topK.value, 10)
                }
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }
            
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                buffer += value;
                let lines = buffer.split('\n');
                buffer = lines.pop(); // Keep partial line for next chunk
                
                for (const line of lines) {
                    if (line.startsWith('data:')) {
                        const jsonStr = line.substring(5).trim();
                        if (jsonStr) {
                            try {
                                const chunkData = JSON.parse(jsonStr);
                                if (chunkData.candidates && chunkData.candidates.length > 0) {
                                    const textPart = chunkData.candidates[0].content?.parts?.[0]?.text;
                                    if (textPart) {
                                        assistantMessage.content += textPart;
                                        updateMessageBubble(assistantMessage.id, assistantMessage.content, true);
                                    }
                                }
                            } catch (e) {
                                console.error("Error parsing Gemini stream chunk:", e, jsonStr);
                            }
                        }
                    }
                }
            }
            
            updateMessageBubble(assistantMessage.id, assistantMessage.content, false); // Final update
            showStatus("Response complete", false);
        }

        async function sendToLlama(assistantMessage, userContentForLlama) {
            const serverUrl = elements.llamaServerUrl.value.trim();
            showStatus("Connecting to Llama server...", false);
            
            // Format history for Llama, using the specially prepared userContentForLlama for the last user message
            const historyForLlama = chatHistory.slice(0, -2); // All messages except current user and empty assistant
            let prompt = "";
            historyForLlama.forEach(message => {
                if (message.role === 'user') {
                    prompt += `USER: ${message.displayContent || message.content}\n`; // Use displayContent for past user messages
                } else if (message.role === 'assistant') {
                    prompt += `ASSISTANT: ${message.content}\n`;
                }
            });
            prompt += `USER: ${userContentForLlama}\nASSISTANT:`; // Add current user message (potentially with embedded files)
            
            const apiUrl = `${serverUrl}/completion`;
            const requestBody = {
                prompt: prompt,
                temperature: parseFloat(elements.temperature.value),
                n_predict: parseInt(elements.maxTokens.value, 10),
                top_p: parseFloat(elements.topP.value),
                top_k: parseInt(elements.topK.value, 10),
                stop: elements.stopSequences.value.split(',').map(s => s.trim()).filter(s => s),
                stream: true
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });
            
            if (!response.ok || !response.body) {
                throw new Error(`Llama Server Error: ${response.status} ${response.statusText}`);
            }
            
            showStatus("Receiving Llama response...", false);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                let lines = buffer.split('\n\n'); // Llama server sends events separated by double newlines
                buffer = lines.pop(); 
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonData = line.substring(6).trim();
                        if (jsonData) {
                            try {
                                const data = JSON.parse(jsonData);
                                if (typeof data.content === 'string') {
                                    assistantMessage.content += data.content;
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, true);
                                }
                                if (data.stop) { // Server might indicate stop
                                    console.log("Llama generation stopped by server.");
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, false);
                                    showStatus("Response complete (Llama)", false);
                                    return; // Exit loop
                                }
                            } catch (e) {
                                console.error("Error parsing Llama stream JSON:", e, jsonData);
                            }
                        }
                    }
                }
            }
            
            updateMessageBubble(assistantMessage.id, assistantMessage.content, false); // Final update
            showStatus("Response complete (Llama)", false);
        }

        async function sendToOpenAI(assistantMessage) {
            const apiKey = elements.openaiApiKey.value.trim();
            const model = elements.openaiModelSelect.value;

            showStatus("Generating response (OpenAI)...", false);

            const messagesForApi = chatHistory.slice(0, -1).map(msg => {
                let contentForApi;
                if (msg.role === 'user') {
                    const contentParts = [{ type: "text", text: msg.displayContent || msg.content }];
                    if (msg.fileInfo && Array.isArray(msg.fileInfo)) {
                        msg.fileInfo.forEach(file => {
                            // OpenAI expects data URLs for images (e.g., "data:image/jpeg;base64,...")
                            if (file.data && file.data.startsWith('data:image/')) {
                                contentParts.push({
                                    type: "image_url",
                                    image_url: { url: file.data }
                                });
                            } else if (file.data && file.data.startsWith('data:')) {
                                // For other file types, if they were read as DataURL, we could try to send as text
                                // but OpenAI vision models are primarily for images.
                                // For now, only include images.
                                console.warn("OpenAI: Non-image file provided, skipping:", file.name, file.type);
                            }
                        });
                    }
                    contentForApi = contentParts;
                } else { // assistant
                    contentForApi = msg.content;
                }
                return { role: msg.role === 'user' ? 'user' : 'assistant', content: contentForApi };
            });

            const apiUrl = `${OPENAI_API_BASE}chat/completions`;
            const requestBody = {
                model: model,
                messages: messagesForApi,
                temperature: parseFloat(elements.temperature.value),
                max_tokens: parseInt(elements.maxTokens.value, 10),
                top_p: parseFloat(elements.topP.value),
                stop: elements.stopSequences.value.split(',').map(s => s.trim()).filter(s => s),
                stream: true
            };
            // top_k is not standard for OpenAI chat completions, so it's omitted.

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            });

            if (!response.ok) {
                 const errorData = await response.json().catch(() => ({})); // Try to parse error
                 throw new Error(`OpenAI API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
            }

            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;

                buffer += value;
                let lines = buffer.split('\n');
                buffer = lines.pop(); // Keep partial line for next chunk

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonStr = line.substring(6).trim();
                        if (jsonStr === '[DONE]') {
                            updateMessageBubble(assistantMessage.id, assistantMessage.content, false);
                            showStatus("Response complete (OpenAI)", false);
                            return;
                        }
                        if (jsonStr) {
                            try {
                                const chunkData = JSON.parse(jsonStr);
                                const delta = chunkData.choices?.[0]?.delta;
                                if (delta?.content) {
                                    assistantMessage.content += delta.content;
                                    updateMessageBubble(assistantMessage.id, assistantMessage.content, true);
                                }
                            } catch (e) {
                                console.error("Error parsing OpenAI stream chunk:", e, jsonStr);
                            }
                        }
                    }
                }
            }
            updateMessageBubble(assistantMessage.id, assistantMessage.content, false); // Final update if loop finishes without [DONE]
            showStatus("Response complete (OpenAI)", false);
        }

        function handleStopGeneration() {
            if (currentAbortController) {
                currentAbortController.abort();
                showStatus("Generation stopped", false);
                // resetSendButton will be called by the finally block of handleSendPrompt
            }
        }

        function resetSendButton() {
            currentAbortController = null;
            elements.sendButton.innerHTML = '<span>Send</span><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>';
            elements.sendButton.classList.remove('stop-button');
            elements.chatInput.disabled = false;
            updateSendButtonState();
            elements.chatInput.focus();
        }

        // File Handling
        function handleFileSelection(event) {
            const files = event.target.files;
            if (!files) return;
            
            const newFiles = Array.from(files).filter(file =>
                !stagedFiles.some(staged => staged.name === file.name)
            );
            
            if (newFiles.length === 0) return;
            showStatus("Processing files...", false);
            
            let filesProcessed = 0;
            newFiles.forEach(file => {
                const reader = new FileReader();
                const fileData = {
                    name: file.name,
                    type: file.type || 'application/octet-stream',
                    content: null, // Will be DataURL or text
                    error: null
                };
                stagedFiles.push(fileData);
                
                reader.onload = function(e) {
                    fileData.content = e.target.result;
                    filesProcessed++;
                    if (filesProcessed === newFiles.length) {
                        renderStagedFiles();
                        showStatus("Files ready", false);
                        updateSendButtonState();
                    }
                };
                
                reader.onerror = function(e) {
                    fileData.error = "Error reading file";
                    filesProcessed++;
                    if (filesProcessed === newFiles.length) {
                        renderStagedFiles();
                        showStatus("Some files had errors", true);
                    }
                };
                
                // For Llama, text files are needed as plain text for embedding.
                // For Gemini and OpenAI, DataURLs are generally preferred for their APIs.
                if (currentModelType === 'llama' && file.type.startsWith('text/')) {
                    reader.readAsText(file);
                } else {
                    // For Gemini, OpenAI, or Llama non-text files (or Llama text if not read as text above)
                    reader.readAsDataURL(file);
                }
            });
            
            renderStagedFiles(); // Show progress immediately
            event.target.value = null; // Clear file input
        }

        function renderStagedFiles() {
            elements.stagedFilesArea.innerHTML = '';
            if (stagedFiles.length === 0) {
                elements.stagedFilesArea.style.display = 'none';
                return;
            }
            
            elements.stagedFilesArea.style.display = 'flex';
            stagedFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'staged-file-item';
                item.innerHTML = `
                    <span>${escapeHtml(file.name)}</span>
                    <button class="remove-file-button" data-index="${index}">&times;</button>
                `;
                elements.stagedFilesArea.appendChild(item);
            });
        }

        function handleRemoveStagedFile(event) {
            if (event.target.classList.contains('remove-file-button')) {
                const index = parseInt(event.target.dataset.index, 10);
                stagedFiles.splice(index, 1);
                renderStagedFiles();
                updateSendButtonState();
            }
        }

        function clearStagedFiles() {
            stagedFiles = [];
            renderStagedFiles();
            elements.fileInput.value = null;
        }

        // Chat Rendering
        function renderChatHistory() {
            if (chatHistory.length === 0) {
                elements.chatContainer.innerHTML = `
                    <div class="empty-state">
                        <h2>Unified AI Chat</h2>
                        <p>Chat with Gemini, Llama, or OpenAI models</p>
                    </div>
                `;
                return;
            }
            
            elements.chatContainer.innerHTML = '';
            chatHistory.forEach(message => {
                const messageElement = createMessageElement(message);
                elements.chatContainer.appendChild(messageElement);
            });
            
            updateSessionButtonState();
        }

        function createMessageElement(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${message.role}-message`;
            if (message.role === 'assistant') {
                messageDiv.className += ` ${message.model}`; // gemini, llama, openai
            }
            messageDiv.dataset.messageId = message.id;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            let avatarChar = 'U';
            if (message.role === 'assistant') {
                if (message.model === 'gemini') avatarChar = 'G';
                else if (message.model === 'llama') avatarChar = 'L';
                else if (message.model === 'openai') avatarChar = 'O';
                else avatarChar = 'A';
            }
            avatarDiv.textContent = avatarChar;
            
            const bodyDiv = document.createElement('div');
            bodyDiv.className = 'message-body';
            
            if (message.role === 'user') {
                // Use displayContent for user message text part.
                bodyDiv.textContent = message.displayContent || message.content;
                
                if (message.fileInfo && message.fileInfo.length > 0) {
                    const fileInfoDiv = document.createElement('div');
                    fileInfoDiv.style.marginTop = '8px';
                    fileInfoDiv.style.fontSize = '0.9em';
                    fileInfoDiv.style.opacity = '0.8';
                    fileInfoDiv.innerHTML = `📎 ${message.fileInfo.map(f => escapeHtml(f.name)).join(', ')}`;
                    bodyDiv.appendChild(fileInfoDiv);
                }
            } else { // Assistant message
                if (message.content) {
                    try {
                        bodyDiv.innerHTML = marked.parse(message.content);
                        requestAnimationFrame(() => addCodeActionsToBubble(bodyDiv));
                    } catch (e) {
                        bodyDiv.textContent = message.content; // Fallback to plain text
                    }
                } else {
                    bodyDiv.innerHTML = '<span class="streaming-indicator">▌</span>'; // Placeholder for streaming
                }
            }
            
            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(bodyDiv);
            messageDiv.appendChild(contentDiv);
            
            return messageDiv;
        }

        function updateMessageBubble(messageId, content, isStreaming) {
            const messageDiv = elements.chatContainer.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageDiv) return;
            
            const bodyDiv = messageDiv.querySelector('.message-body');
            if (!bodyDiv) return;
            
            if (isStreaming && content) { // Continuously update content as text for performance
                bodyDiv.textContent = content; // Simpler update while streaming
                 // Add blinking cursor if streaming and content is not empty
                if (!bodyDiv.querySelector('.streaming-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'streaming-indicator';
                    indicator.textContent = '▌';
                    bodyDiv.appendChild(indicator);
                }
            } else { // Final render with Markdown
                try {
                    bodyDiv.innerHTML = marked.parse(content || '[Empty Response]');
                    addCodeActionsToBubble(bodyDiv); // Add copy/download buttons to code blocks
                } catch (e) {
                    bodyDiv.textContent = content || '[Error rendering response]';
                }
            }
            
            scrollToBottom();
        }


        function addCodeActionsToBubble(container) {
            const preBlocks = container.querySelectorAll('pre');
            preBlocks.forEach(pre => {
                if (pre.querySelector('.code-actions')) return; // Already added
                
                const codeElement = pre.querySelector('code');
                if (!codeElement) return;
                
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'code-actions';
                
                const copyButton = document.createElement('button');
                copyButton.textContent = 'Copy';
                copyButton.className = 'code-action-button copy-code-button';
                copyButton.title = 'Copy code to clipboard';
                
                const downloadButton = document.createElement('button');
                downloadButton.textContent = 'Download';
                downloadButton.className = 'code-action-button download-code-button';
                downloadButton.title = 'Download code as file';
                
                actionsContainer.appendChild(copyButton);
                actionsContainer.appendChild(downloadButton);
                pre.insertBefore(actionsContainer, pre.firstChild); // Add to the top of <pre>
                
                // Ensure highlighting is applied if not already
                if (!codeElement.classList.contains('hljs')) {
                    try {
                        hljs.highlightElement(codeElement);
                    } catch(e) {
                        console.warn("Highlighting failed for code block:", e);
                    }
                }
            });
        }

        function handleCopyCodeClick(button) {
            const pre = button.closest('pre');
            const code = pre?.querySelector('code');
            if (!code) return;
            
            navigator.clipboard.writeText(code.textContent || '').then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                showStatus('Failed to copy code.', true);
            });
        }

        function handleDownloadCodeClick(button) {
            const pre = button.closest('pre');
            const code = pre?.querySelector('code');
            if (!code) return;
            
            const codeContent = code.textContent || '';
            let language = 'txt';
            // Extract language from class e.g. "language-python"
            const langClass = Array.from(code.classList).find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '').split(' ')[0]; // Take first part if multiple (e.g. "language-python python3")
            }
            
            const extensionMap = { /* As before */ 
                javascript: '.js', js: '.js', python: '.py', py: '.py', html: '.html', css: '.css',
                json: '.json', xml: '.xml', yaml: '.yaml', yml: '.yaml', markdown: '.md', md: '.md',
                java: '.java', cpp: '.cpp', c: '.c', csharp: '.cs', cs: '.cs', go: '.go',
                rust: '.rs', ruby: '.rb', php: '.php', sql: '.sql', bash: '.sh', shell: '.sh',
                plaintext: '.txt', text: '.txt'
            };
            
            const extension = extensionMap[language.toLowerCase()] || `.${language}` || '.txt';
            const filename = `code-snippet${extension}`;
            
            const blob = new Blob([codeContent], { type: 'text/plain;charset=utf-f8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Session Management (Existing, should be fine)
        function getSessionIndex() {
            try {
                const indexJson = localStorage.getItem(SESSION_INDEX_KEY);
                if (!indexJson) return [];
                const index = JSON.parse(indexJson);
                return Array.isArray(index) ? index : [];
            } catch (e) {
                console.error("Error reading session index:", e);
                return [];
            }
        }

        function saveSessionIndex(index) {
            try {
                localStorage.setItem(SESSION_INDEX_KEY, JSON.stringify(index));
            } catch (e) {
                console.error("Error saving session index:", e);
                showStatus("Error saving session index", true);
            }
        }

        function populateSessions() {
            const sessions = getSessionIndex();
            elements.sessionsList.innerHTML = '';
            
            sessions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort by most recent

            sessions.forEach(session => {
                const sessionItem = document.createElement('div');
                sessionItem.className = 'session-item';
                sessionItem.dataset.sessionId = session.id;
                sessionItem.innerHTML = `
                    <span>${escapeHtml(session.name)}</span>
                    <button class="delete-btn" title="Delete session">&times;</button>
                `;
                
                if (session.id === currentSessionId) {
                    sessionItem.classList.add('active');
                }
                
                elements.sessionsList.appendChild(sessionItem);
            });
            
            updateSessionButtonState();
        }

        function startNewSession() {
            if (currentAbortController) {
                handleStopGeneration(); // Abort any ongoing generation
            }
            
            chatHistory = [];
            currentSessionId = null;
            messageCounter = 0;
            clearStagedFiles();
            renderChatHistory();
            elements.chatInput.value = '';
            autoResizeTextarea(elements.chatInput);
            showStatus("", false);
            updateSessionButtonState();
            if(!currentAbortController) resetSendButton(); // Reset if not already reset by stop
            
            document.querySelectorAll('.session-item.active').forEach(item => {
                item.classList.remove('active');
            });
            
            closeMobileSidebar();
        }

        function handleSaveSession() {
            if (chatHistory.length === 0) {
                showStatus("Nothing to save", true);
                return;
            }
            
            const sessions = getSessionIndex();
            let defaultName = `Chat ${new Date().toLocaleString()}`;
            
            if (currentSessionId) {
                const existing = sessions.find(s => s.id === currentSessionId);
                if (existing) defaultName = existing.name;
            }
            
            const sessionName = prompt("Enter a name for this session:", defaultName);
            if (!sessionName) return; // User cancelled
            
            const trimmedName = sessionName.trim();
            if (!trimmedName) {
                showStatus("Session name cannot be empty", true);
                return;
            }
            
            try {
                let sessionIdToSave = currentSessionId;
                const now = Date.now();
                
                if (!sessionIdToSave) { // New session
                    sessionIdToSave = `${SESSION_DATA_PREFIX}${now}-${Math.random().toString(36).slice(2, 9)}`;
                    sessions.push({ id: sessionIdToSave, name: trimmedName, timestamp: now });
                    currentSessionId = sessionIdToSave; // Set current ID for this new saved session
                } else { // Existing session
                    const existingIndex = sessions.findIndex(s => s.id === sessionIdToSave);
                    if (existingIndex > -1) {
                        sessions[existingIndex].name = trimmedName;
                        sessions[existingIndex].timestamp = now; // Update timestamp
                    } else { // Should not happen if currentSessionId is set from a loaded session
                        sessions.push({ id: sessionIdToSave, name: trimmedName, timestamp: now });
                    }
                }
                
                localStorage.setItem(`${SESSION_DATA_PREFIX}${sessionIdToSave}`, JSON.stringify(chatHistory));
                saveSessionIndex(sessions); // Save updated index
                populateSessions(); // Re-render session list
                showStatus("Session saved", false);
                
            } catch (e) {
                console.error("Error saving session:", e);
                showStatus("Error saving session (check console for details)", true);
                if (e.name === 'QuotaExceededError') {
                    showStatus("Local storage quota exceeded. Cannot save session.", true);
                }
            }
        }

        function handleLoadSession(sessionId) {
            if (sessionId === currentSessionId && chatHistory.length > 0) return; // Already loaded or current unsaved
            
            try {
                const historyJson = localStorage.getItem(`${SESSION_DATA_PREFIX}${sessionId}`);
                if (!historyJson) throw new Error("Session data not found in local storage");
                
                const loadedHistory = JSON.parse(historyJson);
                if (!Array.isArray(loadedHistory)) throw new Error("Invalid session data format");
                
                if (currentAbortController) {
                     handleStopGeneration();
                }
                
                chatHistory = loadedHistory;
                currentSessionId = sessionId;
                clearStagedFiles();
                
                let maxId = -1;
                chatHistory.forEach(msg => {
                    if (msg.id && msg.id.startsWith('msg-')) {
                        const num = parseInt(msg.id.substring(4), 10);
                        if (!isNaN(num) && num > maxId) maxId = num;
                    }
                });
                messageCounter = maxId + 1;
                
                renderChatHistory();
                showStatus("Session loaded", false);
                populateSessions(); // To highlight the active session
                scrollToBottom();
                if(!currentAbortController) resetSendButton();
                // Infer model type from last message if possible, or default
                const lastAssistantMessage = chatHistory.slice().reverse().find(m => m.role === 'assistant');
                if (lastAssistantMessage && lastAssistantMessage.model) {
                    switchModel(lastAssistantMessage.model);
                }

            } catch (e) {
                console.error("Error loading session:", e);
                showStatus("Error loading session", true);
                startNewSession(); // Fallback to a new session state
            }
        }

        function handleDeleteSession(sessionId) {
            const sessions = getSessionIndex();
            const sessionToDelete = sessions.find(s => s.id === sessionId);
            if (!sessionToDelete) return;
            
            if (!confirm(`Are you sure you want to delete session "${escapeHtml(sessionToDelete.name)}"? This cannot be undone.`)) return;
            
            try {
                localStorage.removeItem(`${SESSION_DATA_PREFIX}${sessionId}`);
                const updatedSessions = sessions.filter(s => s.id !== sessionId);
                saveSessionIndex(updatedSessions);
                
                if (currentSessionId === sessionId) {
                    startNewSession(); // If current session deleted, start a new one
                }
                
                populateSessions();
                showStatus("Session deleted", false);
                
            } catch (e) {
                console.error("Error deleting session:", e);
                showStatus("Error deleting session", true);
            }
        }


        // Import/Export (Existing, should be fine)
        function handleExportAll() {
            const sessions = getSessionIndex();
            if (sessions.length === 0) {
                showStatus("No chats to export.", true);
                return;
            }
            const exportData = {
                version: "1.1", // Increment version if format changes
                exportDate: new Date().toISOString(),
                // No longer storing global modelType here, it's per session or per message
                sessions: []
            };
            
            sessions.forEach(sessionMeta => {
                const historyJson = localStorage.getItem(`${SESSION_DATA_PREFIX}${sessionMeta.id}`);
                if (historyJson) {
                    try {
                        const history = JSON.parse(historyJson);
                        exportData.sessions.push({
                            id: sessionMeta.id, // Exporting original ID
                            name: sessionMeta.name,
                            timestamp: sessionMeta.timestamp,
                            history: history // history now contains model per message
                        });
                    } catch (e) {
                        console.error(`Error parsing session ${sessionMeta.id} for export:`, e);
                    }
                }
            });
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `unified-chat-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus("All chats exported", false);
        }

        function handleImportChats(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target.result);
                    if (!importData.sessions || !Array.isArray(importData.sessions)) {
                        throw new Error("Invalid import file format: 'sessions' array not found.");
                    }
                    
                    const existingSessions = getSessionIndex();
                    let importedCount = 0;
                    let skippedCount = 0;
                    
                    importData.sessions.forEach(sessionData => {
                        // Check if session ID already exists to prevent duplicates from re-import
                        const newSessionId = sessionData.id || `${SESSION_DATA_PREFIX}${sessionData.timestamp || Date.now()}-${Math.random().toString(36).slice(2,9)}`;
                        if (existingSessions.find(s => s.id === newSessionId)) {
                            console.warn(`Skipping import of session "${sessionData.name}", ID "${newSessionId}" already exists.`);
                            skippedCount++;
                            return;
                        }

                        existingSessions.push({
                            id: newSessionId,
                            name: sessionData.name || `Imported Chat ${importedCount + 1}`,
                            timestamp: sessionData.timestamp || Date.now()
                        });
                        
                        // Ensure history messages have IDs if they are missing (for older exports)
                        (sessionData.history || []).forEach((msg, idx) => {
                            if (!msg.id) msg.id = `msg-imported-${idx}-${Date.now()}`;
                        });

                        localStorage.setItem(`${SESSION_DATA_PREFIX}${newSessionId}`, JSON.stringify(sessionData.history || []));
                        importedCount++;
                    });
                    
                    saveSessionIndex(existingSessions);
                    populateSessions();
                    let importStatusMsg = `Imported ${importedCount} sessions.`;
                    if (skippedCount > 0) importStatusMsg += ` Skipped ${skippedCount} (already exist).`;
                    showStatus(importStatusMsg, false);
                    
                } catch (e) {
                    console.error("Import error:", e);
                    showStatus(`Error importing file: ${e.message}`, true);
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Clear file input for re-selection
        }

        // UI Helpers
        function updateSendButtonState() {
            if (currentAbortController) { // If currently generating, stop button is active
                elements.sendButton.disabled = false;
                return;
            }
            
            const hasInput = elements.chatInput.value.trim().length > 0 || stagedFiles.length > 0;
            let canSend = false;
            
            if (currentModelType === 'gemini') {
                const hasApiKey = elements.geminiApiKey.value.trim().length > 0;
                const hasModel = elements.geminiModelSelect.value.length > 0;
                canSend = hasApiKey && hasModel && hasInput;
            } else if (currentModelType === 'llama') {
                const hasValidUrl = isValidHttpUrl(elements.llamaServerUrl.value.trim());
                canSend = hasValidUrl && hasInput;
            } else if (currentModelType === 'openai') {
                const hasApiKey = elements.openaiApiKey.value.trim().length > 0;
                const hasModel = elements.openaiModelSelect.value.length > 0;
                canSend = hasApiKey && hasModel && hasInput;
            }
            
            elements.sendButton.disabled = !canSend;
        }

        function updateSessionButtonState() {
            elements.saveSessionBtn.disabled = chatHistory.length === 0 || currentAbortController !== null;
        }

        async function updateTokenCount() { // Specific to Gemini for now
            if (currentModelType !== 'gemini' || chatHistory.length === 0) {
                elements.tokenCountValue.textContent = '0';
                return;
            }
            
            const apiKey = elements.geminiApiKey.value.trim();
            const model = elements.geminiModelSelect.value;
            
            if (!apiKey || !model) {
                elements.tokenCountValue.textContent = '0';
                return;
            }
            
            elements.tokenCountValue.textContent = '...';
            
            try {
                const contentsForApi = chatHistory.map(msg => {
                    const role = msg.role === 'user' ? 'user' : 'model';
                    const parts = [{ text: msg.displayContent || msg.content }];
                     if (msg.role === 'user' && msg.fileInfo && Array.isArray(msg.fileInfo)) {
                        msg.fileInfo.forEach(file => {
                            if (file.data && file.data.startsWith('data:')) {
                                const [header, base64Data] = file.data.split(',');
                                const mimeType = header.match(/:(.*?);/)?.[1] || file.type;
                                if (base64Data && mimeType) {
                                     parts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
                                }
                            }
                        });
                    }
                    return { role, parts };
                });
                
                const response = await fetch(
                    `${GEMINI_API_BASE}${model}:countTokens?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    elements.tokenCountValue.textContent = data.totalTokens || '0';
                } else {
                    elements.tokenCountValue.textContent = 'N/A';
                    console.warn("Token count failed:", await response.text());
                }
            } catch (error) {
                elements.tokenCountValue.textContent = 'N/A';
                console.warn("Token count error:", error);
            }
        }

        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto'; // Temporarily shrink to get scrollHeight
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px'; // Max height 200px
        }

        function scrollToBottom() {
            requestAnimationFrame(() => {
                elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
            });
        }

        function toggleMobileSidebar() {
            elements.sidebar.classList.toggle('open');
        }

        function closeMobileSidebar() {
            if (window.innerWidth <= 768) { // Only close if on mobile view
                elements.sidebar.classList.remove('open');
            }
        }

        function showStatus(message, isError = false, duration = 3000) {
            elements.statusBar.textContent = message;
            elements.statusBar.classList.remove('error', 'info'); // Remove warning if it existed
            if (isError) {
                elements.statusBar.classList.add('error');
            } else if (message) { // Only add info class if there's a non-error message
                elements.statusBar.classList.add('info');
            }

            if (message && duration > 0) { // Clear status after a delay if message is not empty
                setTimeout(() => {
                    if (elements.statusBar.textContent === message) { // Only clear if it's the same message
                        elements.statusBar.textContent = '';
                        elements.statusBar.classList.remove('error', 'info');
                    }
                }, duration);
            }
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function isValidHttpUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === "http:" || url.protocol === "https:";
            } catch (_) {
                return false;
            }
        }

        // Theme Management (Existing)
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark'; // Default to dark
            setTheme(savedTheme);
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme); // For potential future CSS rules using this
            
            // Update root variables for light/dark mode
            if (theme === 'light') {
                document.documentElement.style.setProperty('--bg', '#ffffff');
                document.documentElement.style.setProperty('--bg-light', '#f0f0f0');
                document.documentElement.style.setProperty('--text', '#212121');
                document.documentElement.style.setProperty('--text-dim', '#555555');
                document.documentElement.style.setProperty('--border', '#dddddd');
                document.querySelector('.sidebar').style.background = '#f9f9f9'; // Example specific adjustment
                document.getElementById('highlight-theme').href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css';
                elements.themeSwitcher.textContent = '🌙'; 
            } else { // dark
                document.documentElement.style.setProperty('--bg', '#212121');
                document.documentElement.style.setProperty('--bg-light', '#2a2a2a');
                document.documentElement.style.setProperty('--text', '#ececf1');
                document.documentElement.style.setProperty('--text-dim', '#a9a9a9');
                document.documentElement.style.setProperty('--border', '#444444');
                document.querySelector('.sidebar').style.background = '#171717';
                document.getElementById('highlight-theme').href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css';
                elements.themeSwitcher.textContent = '☀️';
            }
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme') || 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }

        // Config Management
        function loadConfig() {
            const shouldRemember = localStorage.getItem('rememberUnifiedConfig') === 'true';
            elements.rememberConfig.checked = shouldRemember;
            
            // Default model type
            currentModelType = localStorage.getItem('unifiedModelType') || 'gemini';

            if (shouldRemember) {
                // Gemini
                elements.geminiApiKey.value = localStorage.getItem('unifiedGeminiApiKey') || '';
                // Llama
                elements.llamaServerUrl.value = localStorage.getItem('unifiedLlamaServerUrl') || 'http://127.0.0.1:8080';
                // OpenAI
                elements.openaiApiKey.value = localStorage.getItem('unifiedOpenAIApiKey') || '';
                
                // Settings
                elements.temperature.value = localStorage.getItem('unifiedTemperature') || '0.7';
                elements.maxTokens.value = localStorage.getItem('unifiedMaxTokens') || '2048';
                elements.topP.value = localStorage.getItem('unifiedTopP') || '0.95';
                elements.topK.value = localStorage.getItem('unifiedTopK') || '40';
                elements.stopSequences.value = localStorage.getItem('unifiedStopSequences') || 'USER:, \nUSER:, <|user|>';
            }
        }

        function saveConfig() {
            localStorage.setItem('unifiedModelType', currentModelType);
            if (!elements.rememberConfig.checked) return;
            
            localStorage.setItem('unifiedGeminiApiKey', elements.geminiApiKey.value);
            localStorage.setItem('unifiedLlamaServerUrl', elements.llamaServerUrl.value);
            localStorage.setItem('unifiedOpenAIApiKey', elements.openaiApiKey.value);

            localStorage.setItem('unifiedTemperature', elements.temperature.value);
            localStorage.setItem('unifiedMaxTokens', elements.maxTokens.value);
            localStorage.setItem('unifiedTopP', elements.topP.value);
            localStorage.setItem('unifiedTopK', elements.topK.value);
            localStorage.setItem('unifiedStopSequences', elements.stopSequences.value);
        }

        function handleRememberConfigChange() {
            localStorage.setItem('rememberUnifiedConfig', elements.rememberConfig.checked);
            
            if (elements.rememberConfig.checked) {
                saveConfig(); // Save current values
            } else {
                // Clear saved config (except modelType which is always saved)
                localStorage.removeItem('unifiedGeminiApiKey');
                localStorage.removeItem('unifiedLlamaServerUrl');
                localStorage.removeItem('unifiedOpenAIApiKey');
                localStorage.removeItem('unifiedTemperature');
                localStorage.removeItem('unifiedMaxTokens');
                localStorage.removeItem('unifiedTopP');
                localStorage.removeItem('unifiedTopK');
                localStorage.removeItem('unifiedStopSequences');
            }
        }

        // Initialize the app
        initialize();
    </script>
</body>
</html>
